#!/usr/bin/python

"""
Durdraw by cmang (http://cmang.org) - Ascii art (animation!!!) doodling program

LICENSE:

Copyright 2009-2013 Sam Foster (cmang), all rights reserved

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
"""

import argparse,os.path,pickle,sys,time
import curses
import subprocess
import shutil
import tempfile
from PIL import Image
from copy import copy, deepcopy

class AnsiArt():
    """ Ansi specific stuff.. escape codes, any refs to code page 437, ncurses
        color boilerplate, etc """
    def __init__(self):
        self.ColorPairMap = None # fill this with dict of FG/BG -> curses pair #
        self.escapeFgMap = {   # color numbers documented in initColorPairs() comments
            # ANSI escape code FG colors
            # regular colors, white (1) through to black (8 and 0)
            1:"0;37", 2:"0;36", 3:"0;35", 4:"0;34",
            5:"0;33", 6:"0;32", 7:"0;31", 8:"0;30", 0:"0;30",
            # bright colors, brwhite (9) through to brblack (16)
            9:"1;37", 10:"1;36", 11:"1;35", 12:"1;34",
            13:"1;33", 14:"1;32", 15:"1;31", 16:"1;30"
        }
        self.ansiGraphicsModeTokenMap = {
            """ For parsing ANSI graphics sequence. Eg: ^[0;32;42m is
                green fg (32), magenta bg (42) no bold (0), setting graphics
                mode (m) """
                # expects a function to extract escape sequence then tokenize
                # based on locations of ^[, ; and ending with m.
                # Should this store logical color name strings instead of
                # durdraw color numbers? Then another map can convert names
                # to numbers.
                # * Other ANSI gotchas: Pablodraw uses Cursor Forward (C)
                # commands before each block of characters. Eg: ^[[27C.
                # places a . character at column 27 of the current line.
                # This is different from Durdraw, which would instead place
                # 27 spaces, each escaped to set the color, and then a .
                # character.
            # fg colors
            "37":1, "36":2, "35":3, "34":4, "33":5, "32":6, "31":7, "30":8,
            # bg colors
            "47":1, "46":2, "45":3, "44":4, "43":5, "42":6, "41":7, "40":8,
            # text attributes
            "0":"none",     # non-bold white fg, black bg
            "1":"bold",     # bright color
            "4":"underscore",   # should we handle this?
            "5":"blink",    # iCE color
            "7":"reverse",  # should we handle this?
            "8":"concealed",
        }
        self.escapeBgMap = {
            1:"47", 2:"46", 3:"45", 4:"44",
            5:"43", 6:"42", 7:"41", 8:"40", 0:"40"
        }
    def getColorCode(self, fg, bg):
        """ returns a string containing ANSI escape code for given fg/bg  """
        escape = '\033['    # begin escape sequence
        escape = escape + self.escapeFgMap[fg] + ';'  # set fg color
        escape = escape + self.escapeBgMap[bg]  # set bg color
        escape = escape + "m"   # m = set graphics mode command
        return escape
    def codePage437(self): 
        pass
    def initColorPairs(self):
       """ Setup ncurses color pairs for ANSI colors """
       # this kind of hurts to write. wtf, ncurses.
       # basic ncurses colors - comments for these are durdraw internal color numbers:
       curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK) # white - 1
       curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) # cyan - 2
       curses.init_pair(3, curses.COLOR_MAGENTA, curses.COLOR_BLACK) # magenta - 3
       curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)  # blue - 4
       curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK) # yellow - 5
       curses.init_pair(6, curses.COLOR_GREEN, curses.COLOR_BLACK) # green - 6
       curses.init_pair(7, curses.COLOR_RED, curses.COLOR_BLACK) # red - 7
       curses.init_pair(8, curses.COLOR_BLACK, curses.COLOR_BLACK) # black - 8 (and 0)
       # white with background colors
       curses.init_pair(9, curses.COLOR_WHITE, curses.COLOR_WHITE) # 1,1
       curses.init_pair(10, curses.COLOR_WHITE, curses.COLOR_CYAN) # 1,2
       curses.init_pair(11, curses.COLOR_WHITE, curses.COLOR_MAGENTA) # 1,3
       curses.init_pair(12, curses.COLOR_WHITE, curses.COLOR_BLUE)  # 1,4
       curses.init_pair(13, curses.COLOR_WHITE, curses.COLOR_YELLOW)  # 1,5
       curses.init_pair(14, curses.COLOR_WHITE, curses.COLOR_GREEN) # 1,6
       curses.init_pair(15, curses.COLOR_WHITE, curses.COLOR_RED)   # 1,7
       # cyan with background colors
       curses.init_pair(16, curses.COLOR_CYAN, curses.COLOR_WHITE) # 2,1
       curses.init_pair(17, curses.COLOR_CYAN, curses.COLOR_CYAN) # 2,2
       curses.init_pair(18, curses.COLOR_CYAN, curses.COLOR_MAGENTA) # 2,3
       curses.init_pair(19, curses.COLOR_CYAN, curses.COLOR_BLUE)  # 2,4
       curses.init_pair(20, curses.COLOR_CYAN, curses.COLOR_YELLOW)  # 2,5
       curses.init_pair(21, curses.COLOR_CYAN, curses.COLOR_GREEN) # 2,6
       curses.init_pair(22, curses.COLOR_CYAN, curses.COLOR_RED)   # 2,7
       # magenta with background colors
       curses.init_pair(23, curses.COLOR_MAGENTA, curses.COLOR_WHITE) # 3,1
       curses.init_pair(24, curses.COLOR_MAGENTA, curses.COLOR_CYAN) # 3,2
       curses.init_pair(25, curses.COLOR_MAGENTA, curses.COLOR_MAGENTA) # 3,3
       curses.init_pair(26, curses.COLOR_MAGENTA, curses.COLOR_BLUE)  # 3,4
       curses.init_pair(27, curses.COLOR_MAGENTA, curses.COLOR_YELLOW)  # 3,5
       curses.init_pair(28, curses.COLOR_MAGENTA, curses.COLOR_GREEN) # 3,6
       curses.init_pair(29, curses.COLOR_MAGENTA, curses.COLOR_RED)   # 3,7
       # blue with background colors
       curses.init_pair(30, curses.COLOR_BLUE, curses.COLOR_WHITE) # 4,1
       curses.init_pair(31, curses.COLOR_BLUE, curses.COLOR_CYAN) # 4,2
       curses.init_pair(32, curses.COLOR_BLUE, curses.COLOR_MAGENTA) # 4,3
       curses.init_pair(33, curses.COLOR_BLUE, curses.COLOR_BLUE)  # 4,4
       curses.init_pair(34, curses.COLOR_BLUE, curses.COLOR_YELLOW)  # 4,5
       curses.init_pair(35, curses.COLOR_BLUE, curses.COLOR_GREEN) # 4,6
       curses.init_pair(36, curses.COLOR_BLUE, curses.COLOR_RED)   # 4,7
       # yellow with background colors
       curses.init_pair(37, curses.COLOR_YELLOW, curses.COLOR_WHITE) # 5,1
       curses.init_pair(38, curses.COLOR_YELLOW, curses.COLOR_CYAN) # 5,2
       curses.init_pair(39, curses.COLOR_YELLOW, curses.COLOR_MAGENTA) # 5,3
       curses.init_pair(40, curses.COLOR_YELLOW, curses.COLOR_BLUE)  # 5,4
       curses.init_pair(41, curses.COLOR_YELLOW, curses.COLOR_YELLOW)  # 5,5
       curses.init_pair(42, curses.COLOR_YELLOW, curses.COLOR_GREEN) # 5,6
       curses.init_pair(43, curses.COLOR_YELLOW, curses.COLOR_RED)   # 5,7
       # green with background colors
       curses.init_pair(44, curses.COLOR_GREEN, curses.COLOR_WHITE) # 6,1
       curses.init_pair(45, curses.COLOR_GREEN, curses.COLOR_CYAN) # 6,2
       curses.init_pair(46, curses.COLOR_GREEN, curses.COLOR_MAGENTA) # 6,3
       curses.init_pair(47, curses.COLOR_GREEN, curses.COLOR_BLUE)  # 6,4
       curses.init_pair(48, curses.COLOR_GREEN, curses.COLOR_YELLOW)  # 6,5
       curses.init_pair(49, curses.COLOR_GREEN, curses.COLOR_GREEN) # 6,6
       curses.init_pair(50, curses.COLOR_GREEN, curses.COLOR_RED)   # 6,7
       # red with background colors
       curses.init_pair(51, curses.COLOR_RED, curses.COLOR_WHITE) # 7,1
       curses.init_pair(52, curses.COLOR_RED, curses.COLOR_CYAN) # 7,2
       curses.init_pair(53, curses.COLOR_RED, curses.COLOR_MAGENTA) # 7,3
       curses.init_pair(54, curses.COLOR_RED, curses.COLOR_BLUE)  # 7,4
       curses.init_pair(55, curses.COLOR_RED, curses.COLOR_YELLOW)  # 7,5
       curses.init_pair(56, curses.COLOR_RED, curses.COLOR_GREEN) # 7,6
       #curses.init_pair(57, curses.COLOR_RED, curses.COLOR_RED)   # 7,7
       # black with background colors
       curses.init_pair(58, curses.COLOR_BLACK, curses.COLOR_WHITE) # 8,1
       curses.init_pair(59, curses.COLOR_BLACK, curses.COLOR_CYAN) # 8,2
       curses.init_pair(60, curses.COLOR_BLACK, curses.COLOR_MAGENTA) # 8,3
       curses.init_pair(61, curses.COLOR_BLACK, curses.COLOR_BLUE)  # 8,4
       curses.init_pair(62, curses.COLOR_BLACK, curses.COLOR_YELLOW)  # 8,5
       curses.init_pair(63, curses.COLOR_BLACK, curses.COLOR_GREEN) # 8,6
       curses.init_pair(57, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
       #curses.init_pair(64, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
       # ^ this doesn't work ?!@ ncurses pair # must be between 1 and 63
       # or ncurses (const?) COLOR_PAIR - 1 
       # fix is: have functions to swap color map from blackfg to normal.
       # call that function when drawing if the fg color is black, then switch back
       # after each character. Or.. keep track which map we're in in a variable.
       self.colorPairMap = {
            # foreground colors, black background
            (0,0):1, (1,0):1, (2,0):2, (3,0):3, (4,0):4, (5,0):5, (6,0):6, (7,0):7, (8,0):8,
            # and again, because black is both 0 and 8. :| let's just ditch 0?
            (0,8):1, (1,8):1, (2,8):2, (3,8):3, (4,8):4, (5,8):5, (6,8):6, (7,8):7, (8,8):8,
            # white with backround colors 
            (1,1):9, (1,2):10, (1,3):11, (1,4):12, (1,5):13, (1,6):14, (1,7):15,
            # cyan with backround colors 
            (2,1):16, (2,2):17, (2,3):18, (2,4):19, (2,5):20, (2,6):21, (2,7):22,
            # magenta with background colors
            (3,1):23, (3,2):24, (3,3):25, (3,4):26, (3,5):27, (3,6):28, (3,7):29,
            # blue with background colors
            (4,1):30, (4,2):31, (4,3):32, (4,4):33, (4,5):34, (4,6):35, (4,7):36,
            # yellow with background colors
            (5,1):37, (5,2):38, (5,3):39, (5,4):40, (5,5):41, (5,6):42, (5,7):43,
            # green with background colors
            (6,1):44, (6,2):45, (6,3):46, (6,4):47, (6,5):48, (6,6):49, (6,7):50,
            # red with background colors
            (7,1):51, (7,2):52, (7,3):53, (7,4):54, (7,5):55, (7,6):56, (7,7):57,
            # black with background colors
            (8,1):58, (8,2):58, (8,3):60, (8,4):61, (8,5):62, (8,6):63, 
            (8,7):57,  # 57 instead of 64, because we switch color maps for black
            # on red
            # BRIGHT COLORS 9-16
            # white with backround colors 
            (9,0):1, (9,8):1, (9,1):9, (9,2):10, (9,3):11, (9,4):12, (9,5):13, (9,6):14, (9,7):15,
            # cyan with backround colors 
            (10,0):2, (10,8):2, (10,1):16, (10,2):17, (10,3):18, (10,4):19, (10,5):20, (10,6):21, (10,7):22,
            # magenta with background colors
            (11,0):3, (11,8):3, (11,1):23, (11,2):24, (11,3):25, (11,4):26, (11,5):27, (11,6):28, (11,7):29,
            # blue with background colors
            (12,0):4, (12,8):4, (12,1):30, (12,2):31, (12,3):32, (12,4):33, (12,5):34, (12,6):35, (12,7):36,
            # yellow with background colors
            (13,0):5, (13,8):5, (13,1):37, (13,2):38, (13,3):39, (13,4):40, (13,5):41, (13,6):42, (13,7):43,
            # green with background colors
            (14,0):6, (14,8):6, (14,1):44, (14,2):45, (14,3):46, (14,4):47, (14,5):48, (14,6):49, (14,7):50,
            # red with background colors
            (15,0):7, (15,8):7, (15,1):51, (15,2):52, (15,3):53, (15,4):54, (15,5):55, (15,6):56, (15,7):57,
            # black with background colors
            (16,0):8, (16,8):8, (16,1):58, (16,2):58, (16,3):60, (16,4):61, (16,5):62, (16,6):63, 
            (16,7):57,  # 57 instead of 64, because we switch color maps for black
            } # (fg,bg):cursespair
    def switchColorMap(self, map=0):    # deprecated?  I think so.
            if (map == 1):   # 1 = black map.. deal with it. pair 57 is black on red.
                # black with background colors
                curses.init_pair(57, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
            elif (map == 0):  # 0 = normal color map, pair 57 is red on red 
                curses.init_pair(57, curses.COLOR_RED, curses.COLOR_RED)   # 7,7


class Frame():
    """Frame class - single canvas size frame of animation. a traditional drawing.
    """
    def __init__(self, sizeX, sizeY):
        """ Initialize frame, content[x][y] grid """
        # it's a bunch of rows of ' 'characters.
        self.content = []
        self.sizeX = sizeX
        self.sizeY = sizeY
        self.delay = 0  # delay is # of sec to wait at this frame.
        for x in range(0, sizeY):
            self.content.append([])
            for y in range(0, sizeX):
                self.content[x].append(' ')
        self.initColorMap()
        self.setDelayValue(0)

    def setDelayValue(self, delayValue):
        self.delay = delayValue

    def initColorMap(self):
        """ Builds a dictionary mapping X/Y to a FG/BG color pair """
        self.colorMap = {}
        for x in range(0, self.sizeY):
            for y in range(0, self.sizeX):
                self.colorMap.update( {(x,y):(1,0)} )  # tuple keypair (xy), tuple value (fg and bg)

class Options():    # config, prefs, preferences, etc. Per movie. Separate from AppState options.
    """ Member variables are canvas X/Y size, Framerate, Video resolution, etc """
    def __init__(self):         # default options
        self.framerate = 2.0
        self.sizeX = 79
        self.sizeY = 23
        self.saveFileFormat = 4 # save file format version number

class Movie():
    """ Contains an array of Frames, options to add, remove, copy them """
    def __init__(self, opts):
        self.frameCount = 0  # total number of frames
        self.currentFrameNumber = 0
        self.sizeX = opts.sizeX
        self.sizeY = opts.sizeY
        self.frames = []
        self.addEmptyFrame()
        self.currentFrameNumber = self.frameCount
        self.currentFrame = self.frames[self.currentFrameNumber - 1] 

    def addEmptyFrame(self):
        newFrame = Frame(self.sizeX, self.sizeY)
        self.frames.append(newFrame)
        self.frameCount += 1

    def cloneNewFrame(self):    # clone current frame onto a new frame
        newFrame = Frame(self.sizeX, self.sizeY)
        self.frames.append(newFrame)
        newFrame.content = deepcopy(self.currentFrame.content)
        newFrame.colorMap = deepcopy(self.currentFrame.colorMap)
        self.frameCount += 1

    def deleteCurrentFrame(self):
        if (self.frameCount == 1):
            del self.frames[self.currentFrameNumber - 1]
            # deleted the last frame, so make a blank one
            newFrame = Frame(self.sizeX, self.sizeY)
            self.frames.append(newFrame)
            self.currentFrame = self.frames[self.currentFrameNumber - 1]
        else:
            del self.frames[self.currentFrameNumber - 1]
            self.frameCount -= 1
            if (self.currentFrameNumber != 1):
                self.currentFrameNumber -= 1
            self.currentFrame = self.frames[self.currentFrameNumber - 1]

    def moveFramePosition(self, startPosition, newPosition):
        """ move the frame at startPosition to newPosition """
        # use push and pop to remove and insert it
        fromIndex = startPosition - 1
        toIndex = newPosition - 1
        self.frames.insert(toIndex, self.frames.pop(fromIndex))

    def goToFrame(self, frameNumber):
        if frameNumber > 0 and frameNumber < self.frameCount:
            self.currentFrameNumber = frameNumber
            self.currentFrame = self.frames[self.currentFrameNumber - 1]
    
    def nextFrame(self):
        if (self.currentFrameNumber == self.frameCount):    # if at last frame..
            self.currentFrameNumber = 1     # cycle back to the beginning
            self.currentFrame = self.frames[self.currentFrameNumber - 1] # -1 bcuz frame 1 = self.frames[0]
        else:
            self.currentFrameNumber += 1
            self.currentFrame = self.frames[self.currentFrameNumber - 1]

    def prevFrame(self):
        if (self.currentFrameNumber == 1):
            self.currentFrameNumber = self.frameCount
            self.currentFrame = self.frames[self.currentFrameNumber - 1]
        else:
            self.currentFrameNumber -= 1
            self.currentFrame = self.frames[self.currentFrameNumber - 1]

    def lastMovieLine():
        pass

class CursesUI():   # Use this to isolate ncurses calls and objects,
    # Use same interface for HtmlUI, etc. Perhaps CursesView() is a better name.
    """ This talks a common UI language with UserInterface and contains all
        ncurses calls and objects """
    def __init__(self): # I guess this should load curses.wrapper(start), etc?
        # this stuff may be better in 
        curses.wrapper(start)
        curses.start_color()
        curses.mousemask(1)
    def addstr(self, y, x, str, attr=None): # addstr(y, x, str[, attr]) and addstr(str[, attr])
        """ Wraps ncurses addstr in a try;except, prevents addstr from
            crashing cureses if it fails """
        if not attr:
            try:
                self.stdscr.addstr(y, x, str)
            except curses.error:
                self.testWindowSize()
        else:
            try:
                self.stdscr.addstr(y, x, str, attr)
            except curses.error:
                self.testWindowSize()

class UserInterface():  # Separate view (curses) from this controller
    """ Draws user interface, has main UI loop. """
    def __init__(self):
        self.opts = Options()    # so we can use opts.sizeX and opts.sizeY. Needed by Frame(), subsequently Movie()
        self.appState = None # will be filled in by main() .. run-time app state stuff
        self.initCharSet()  # sometimes later options can store a char set to init - utf-8, cp437, etc.
        # initialize screen and draw the 'canvas'
        self.stdscr = curses.initscr()
        curses.start_color()    # Yeayuhhh
        curses.mousemask(1)     # it's a party now.
        self.ansi = AnsiArt()   # obj for misc ansi-related stuff
        self.ansi.initColorPairs()  # set up ncurses color pairs and fg/bg map
        self.colorfg = 1    # default fg white
        self.colorbg = 0    # default bg black
        self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        self.mov = Movie(self.opts) # initialize a new movie to work with
        self.undo = UndoManager(self)   # initialize undo/redo system
        self.xy = [0, 1]     # cursor position x/y - was "curs"
        self.playing = False
        curses.noecho()
        curses.raw()
        curses.nonl()
        self.stdscr.keypad(1)
        self.testWindowSize()
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()

    def setAppState(self, appState):
        """ Takes the app state (running config options) and makes any changes
            needed to the UI/etc to honor that app state """
        self.appState = appState
        # set undo history size
        self.undo.setHistorySize(self.appState.undoHistorySize)

    def nextFgColor(self):
        """ switch to next fg color, cycle back to beginning at max """
        if (self.colorfg < 16):
            self.colorfg += 1
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorfg += 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorfg = 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def prevFgColor(self):
        """ switch to prev fg color, cycle around to end if at beginning """
        if (self.colorfg > 1):
            self.colorfg -= 1
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorfg -= 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorfg = 16
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def nextBgColor(self):
        """ switch to the next bg color, cycle around if at beginning """
        if (self.colorbg < 8):
            self.colorbg += 1
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorbg += 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorbg = 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def prevBgColor(self):
        """ switch to prev bg color, cycle around to end if at beginning """
        if (self.colorbg > 1):
            self.colorbg -= 1
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorbg -= 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorbg = 8
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def cursorOff(self):
        try:
            curses.curs_set(0)  # turn off cursor
        except curses.error:
            pass    # .. if terminal supports it.

    def cursorOn(self):
        try:
            curses.curs_set(1)  # turn on cursor
        except curses.error:
            pass    # .. if terminal supports it.

    def addstr(self, y, x, str, attr=None): # addstr(y, x, str[, attr]) and addstr(str[, attr])
        """ Wraps ncurses addstr in a try;except, prevents addstr from
            crashing cureses if it fails """
        if not attr:
            try:
                self.stdscr.addstr(y, x, str)
            except curses.error:
                self.testWindowSize()
        else:
            try:
                self.stdscr.addstr(y, x, str, attr)
            except curses.error:
                self.testWindowSize()
    def move(self, y, x):
        try:
            self.stdscr.move(y, x)
        except curses.error:
            self.testWindowSize()

    def notify(self, message, pause=False):
        self.cursorOff()
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, message)
        self.stdscr.refresh()
        if pause:
            self.stdscr.getch()
        if not pause:
            curses.napms(1500)
            curses.flushinp()
        self.clearStatusLine()
        self.cursorOn()
        self.stdscr.refresh()

    def testWindowSize(self):
        """Test to see if window is too small for program to operate, and
        go into small window mode if necessary"""
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx() # test size
        if (self.realmaxY < self.mov.sizeY+1) or (self.realmaxX < self.mov.sizeX):
            self.smallWindowMode()   # go into small window loop.stdscr
        if self.realmaxX < (self.mov.sizeX-4):
            self.smallWindowMode()   # go into small window loop.stdscr

    def smallWindowMode(self):
        """Clear the screen, draw a small message near 0,0 that the window
        is too small.  Keep doing so until the screen is resized larger."""
        self.stdscr.clear()
        self.stdscr.refresh()
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()
        while (self.realmaxY < self.mov.sizeY+1 or self.realmaxX < self.mov.sizeX):
            self.addstr(0, 0, "Window is too small.")
            self.addstr(1, 0, "Please enlarge to 80x25 or larger.")
            self.stdscr.refresh()
            self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()
        self.stdscr.refresh()
        self.testWindowSize()

    def insertChar(self, c, fg=1, bg=0):
        """ insert character at current location, move cursor to the right (unless at the edge of canvas) """
        self.undo.push()
        self.mov.currentFrame.content[self.xy[0]][self.xy[1] - 1] = chr(c)
        self.mov.currentFrame.colorMap.update(
                {(self.xy[0],self.xy[1] - 1):(fg,bg)} )
        if self.xy[1] < self.mov.sizeX:
            self.xy[1] = self.xy[1] + 1 

    def clearCanvas(self, prompting = False):
        clearing = True  # assume we are clearing unless we prompt and say "n"
        if prompting:
            self.stdscr.nodelay(0) # wait for input when calling getch
            self.clearStatusLine()
            self.addstr(self.mov.sizeY, 0, "Are you sure you want to clear the canvas? (Y/N) " )
            while (prompting):
                time.sleep(0.01)
                c = self.stdscr.getch()
                if (c == 121):   # 121 = y
                    clearing = True
                    prompting = False
                elif (c == 110): # 110 = n
                    clearing = False
                    prompting = False
            self.clearStatusLine()
        if clearing:
            self.undo.push() # so we can undo this operation
            self.mov = Movie(self.opts) # initialize a new movie

    def moveCurrentFrame(self):
        self.undo.push()
        prompting = True
        self.clearStatusLine()
        startPosition = self.mov.currentFrameNumber
        newPosition = self.mov.currentFrameNumber
        while prompting:
            time.sleep(0.01)
            self.addstr(self.mov.sizeY, 0, "Use left/right to move frame, press Enter when done or Esc to cancel. (%i/%i)" % (newPosition, self.mov.frameCount))
            c = self.stdscr.getch()
            if c in [98, curses.KEY_LEFT]:
                # move frame left one position (use pop and push)
                if newPosition is 1: # if at first
                    newPosition = self.mov.frameCount # go to end
                else:
                    newPosition -= 1
            elif c in [102, curses.KEY_RIGHT]:
                if newPosition is self.mov.frameCount: # if at last
                    newPosition = 1 # go back to beginning
                else:
                    newPosition += 1
            elif c in [13, curses.KEY_ENTER]: # enter - save  new position
                self.mov.moveFramePosition(startPosition, newPosition)
                self.mov.goToFrame(newPosition)
                prompting = False
            elif c in [27]: # escape - cancel
                self.undo.undo()
                prompting = False
        #self.clearStatusLine()
        #self.drawStatusBar()
        #self.refresh()

    def animLoop(self): # improved game loop - watches for FPS based on a delta from previous time
        self.stdscr.nodelay(1) # do not wait for input when calling getch
        last_time = time.time()
        self.cursorOff()
        self.playing = True
        new_time = time.time()
        # see how many milliseconds we have to sleep for
        # then divide by 1000.0 since time.sleep() uses seconds
        sleep_time = (1000.0 / self.opts.framerate) / 1000.0
        while (self.playing):
            # catch keyboard input - to change framerate or stop playing animation
            # get keyboard input, returns -1 if none available
            self.refresh()
            c = self.stdscr.getch()
            if (c != -1):   # -1 means no keys are pressed.
                # up or down to change framerate, otherwise stop playing
                if c == curses.KEY_UP:  # up key - increase fps
                    if (self.opts.framerate != 50): # max 40fps
                        self.opts.framerate += 1
                        sleep_time = (1000.0 / self.opts.framerate) / 1000.0
                elif c == curses.KEY_DOWN:    # down key - decrese fps
                    if (self.opts.framerate != 1.0): # min 1fps
                        self.opts.framerate -= 1
                        sleep_time = (1000.0 / self.opts.framerate) / 1000.0
                elif c in [113, 81] and self.appState.playOnlyMode:    # q or Q
                    self.verySafeQuit()
                else:
                    self.playing = False # press most any key to stop
            new_time = time.time()
            frame_delay = self.mov.currentFrame.delay
            if frame_delay > 0:
                realDelayTime = frame_delay
            else:
                realDelayTime = sleep_time
            #if (new_time >= (last_time + sleep_time + frame_delay)): # Time to update the frame? If so...
            if (new_time >= (last_time + realDelayTime)): # Time to update the frame? If so...
                last_time = new_time
                # draw animation
                self.mov.nextFrame()
                if not self.appState.playOnlyMode: # if we're in play-only
                    # mode, don't show extra stuff.
                    self.drawStatusBar()
                #self.refresh()
            else: time.sleep(0.005) # to keep from sucking up cpu
        self.stdscr.nodelay(0) # back to wait for input when calling getch
        self.cursorOn()
    
    def initCharSet(self): # we can have nextCharSet and PrevCharSet to switch between chars in set
        # Can also add encoding= paramater for different encodings, eg: ascii, utf-8, etc.
        """ Map a dict of F1-f10 to character values """ 
        self.chMap = {'f1':176, 'f2':177, 'f3':178, 'f4':219, 'f5':223, 'f6':220, 'f7':221, 'f8':222, 'f9':254, 'f10':250 }
        self.chMapString = "F1%cF2%cF3%cF4%cF5%cF6%cF7%cF8%cF9%cF10%c" % \
                (self.chMap['f1'], self.chMap['f2'], self.chMap['f3'], self.chMap['f4'], self.chMap['f5'], \
                self.chMap['f6'], self.chMap['f7'], self.chMap['f8'], self.chMap['f9'], self.chMap['f10'], )

    def clearStatusLine(self):
        # fyi .. sizeX and sizeY in this context should go into
        # appState, not in Movie(). In other words, this is not
        # the sizeX and sizeY of the movie, but of the editor screen.
        self.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)

    def drawStatusBar(self):
        self.clearStatusLine()
        statusBar = "%s (%i/%i) FPS: %i D: %i " % \
            (str(self.xy),
            self.mov.currentFrameNumber, \
            self.mov.frameCount, \
            self.opts.framerate, \
            self.mov.currentFrame.delay)
        self.addstr(self.mov.sizeY, 2, statusBar)
        # f1-f10 map
        # color thing
        chMapOffset = self.mov.sizeX - len(self.chMapString)-1
        if self.colorfg > 8:    # bright color
            self.addstr(self.mov.sizeY, chMapOffset, self.chMapString, curses.color_pair(self.colorpair) | curses.A_BOLD)
        else:   # normal color
            self.addstr(self.mov.sizeY, chMapOffset, self.chMapString, curses.color_pair(self.colorpair))
        # draw transport
        #if self.playing:
        #    transportString = "      ||      " 
        #else:
        #    transportString = "|< << |> >> >|" 
        #transportOffset = chMapOffset - len(transportString) - 1
        #self.addstr(self.mov.sizeY, transportOffset, transportString)

    def mainLoop(self):
        self.metaKey = 0
        while 1:    # Real "main loop" - get user input, aka "edit mode"
            self.testWindowSize()
            # print statusbar stuff
            self.drawStatusBar()
            self.move(self.xy[0], self.xy[1] - 1)  # move cursor to the right
            # spot for refresh
            self.stdscr.refresh()
            c = self.stdscr.getch()
            self.testWindowSize()
            #if c == 203: self.notify('Whaaaaat???')
            if c in ["\x1b\x1b\x5b\x42"]: self.notify("alt-down")
            if self.metaKey == 1:
                # Try for meta-keys, then set metaKey to 1
                if c == 111:                # alt-o - open
                    self.open()
                    c = None
                elif c == 115:                 # alt-s - save
                    self.save()
                    c = None
                elif c == 113:                 # alt-q - quit
                    self.safeQuit()
                    c = None
                elif c == 104:                # alt-h - help
                    self.showHelp()
                    c = None
                elif c in [98, curses.KEY_LEFT]:      # alt-left - prev bg color
                    self.prevBgColor()
                    c = None
                elif c in [102, curses.KEY_RIGHT]:     # alt-right - next bg color
                    self.nextBgColor()
                    c = None
                elif c in [curses.KEY_DOWN, "\x1b\x1b\x5b\x42"]:      # alt-down - prev fg color
                    self.prevFgColor()
                    c = None
                elif c == curses.KEY_UP:     # alt-up - next fg color
                    self.nextFgColor()
                    c = None
                elif c == 44:      # alt-, - erase/pop current column
                    self.delCol()
                elif c == 46:       # alt-. - insert column
                    self.addCol()
                elif c == 39:        # alt-' - erase line
                    self.delLine()
                elif c == 47:      # alt-/ - insert line
                    self.addLine()
                elif (c == 109):    # alt-m - mark block
                    startPoint=(self.xy[0], self.xy[1])
                    self.startSelecting(startPoint)
                elif (c == 99):     # alt-c - clear canvas
                    self.clearCanvas(prompting = True)
                # Animation Keystrokes
                elif (c == 68):     #alt-D - set delay for current frame
                    self.getDelayValue()
                    pass
                elif (c == 107):          # alt-k - next frame
                    self.mov.nextFrame()
                    self.refresh()  
                elif (c == 106):          # alt-j or alt-j - previous frame
                    self.mov.prevFrame()
                    self.refresh()
                elif (c == 110) or (c == 14):          # alt-n - clone to new frame
                    self.undo.push()
                    self.mov.cloneNewFrame()
                    self.refresh()
                elif (c == 78):          # alt-N (shift-alt-n) - new  empty frame
                    self.undo.push()
                    self.mov.addEmptyFrame()
                    self.refresh()
                elif (c == 77):         # alt-M - move current frame
                    self.moveCurrentFrame()
                    pass
                elif (c == 100):      # alt-d - delete current frame
                    self.deleteCurrentFramePrompt()
                    self.refresh()
                elif c is 122:  # cmd-z = undo
                    self.undo.undo()
                elif c is 114:  # cmd-r = redo
                    self.undo.redo()
                elif (c == 112):    # esc-p - start playing, any key exits
                    self.animLoop()
                else: self.notify("keystroke: %d" % c)
                self.metaKey = 0
                c = None
            if c == 27: self.metaKey = 1; c = None
            if c == 24: self.safeQuit()     # ctrl-x
            elif c == 15:               # ctrl-o - open
                self.open()
                c = None
            elif c == 23:               # ctrl-w - save
                self.save()
                c = None
            elif c == 12:               # ctrl-l - harder refresh
                self.stdscr.redrawwin()
                self.refresh()
                c = None
            elif c in [13, curses.KEY_ENTER]:               # enter (10 if we don't do curses.nonl())
                if self.xy[0] < self.mov.sizeX - 1:
                    self.xy = [self.xy[0] + 1, 1]
            elif c in [263, 127]:              # backspace
                if self.xy[1] > 1: self.xy[1] = self.xy[1] - 1
            elif c in [1, curses.KEY_HOME]:     # ctrl-a or home
                self.xy[1] = 1
            elif c in [5, curses.KEY_END]:      # ctrl-e or end
                self.xy[1] = self.mov.sizeX
            elif c in [curses.KEY_F1]:    # F1 - insert extended character
                self.insertChar(self.chMap['f1'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F2]:    # F2 - insert extended character
                self.insertChar(self.chMap['f2'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F3]:    # F3 - insert extended character
                self.insertChar(self.chMap['f3'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F4]:    # F4 - insert extended character
                self.insertChar(self.chMap['f4'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F5]:    # F5 - insert extended character
                self.insertChar(self.chMap['f5'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F6]:    # F6 - insert extended character
                self.insertChar(self.chMap['f6'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F7]:    # F7 - insert extended character
                self.insertChar(self.chMap['f7'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F8]:    # F8 - insert extended character
                self.insertChar(self.chMap['f8'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F9]:    # F9 - insert extended character
                self.insertChar(self.chMap['f9'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c in [curses.KEY_F10]:    # F10 - insert extended character
                self.insertChar(self.chMap['f10'], fg=self.colorfg, bg=self.colorbg)
                c = None
            elif c == curses.KEY_LEFT:      # left - move cursor right a character
                if self.xy[1] > 1: self.xy[1] = self.xy[1] - 1
            elif c == curses.KEY_RIGHT:     # right - move cursor right
                if self.xy[1] < self.mov.sizeX: self.xy[1] = self.xy[1] + 1
            elif c == curses.KEY_UP:    # up - move cursor up
                if self.xy[0] > 0: self.xy[0] = self.xy[0] - 1
            elif c == curses.KEY_DOWN:  # down - move curosr down
                if self.xy[0] < self.mov.sizeY - 1: self.xy[0] = self.xy[0] + 1
            elif c in [339, curses.KEY_HOME]:  # 339 = home
                self.xy[1] = 1
            elif c in [338, curses.KEY_END]:   # 338 = end
                self.xy[1] = self.mov.sizeX
            elif c == curses.KEY_MOUSE: # mouse = move cursor, etc
                #mouseEvent = curses.getmouse()
                _, mouseX, mouseY, _, _ = curses.getmouse()
                if mouseY < self.mov.sizeY:
                    self.xy[1] = mouseX + 1 # set cursor position
                    self.xy[0] = mouseY
                else:   # we clicked on the status bar somewhere..
                    # Add stuff here to take mouse 'commands' like clicking
                    # play/next/etc on transport, or clicking "start button"
                    pass
                #self.mouseClicked(mouseEvent)
            elif c in [curses.KEY_SLEFT, curses.KEY_SRIGHT, 337, 336, 520, 513]:
                # 337 and 520 - shift-up, 336 and 513 = shift-down
                # shift-up, shift-down, shift-left and shift-right = start selecting text block
                # shift-up and shift-down not defined in ncurses :(
                # doesn't seem to work in screen?
                startPoint=(self.xy[0], self.xy[1])
                self.startSelectingShift(c, startPoint)  # start selecting text
                # pass c to something here that starts selecting and moves
                # the cursor based on c, and knows whether it's selecting
                # via shift-arrow or mouse.
            elif c <= 128 and c >= 32:      # normal printable character
                self.insertChar(c, fg=self.colorfg, bg=self.colorbg)
            self.drawStatusBar()
            self.refresh()

    def getDelayValue(self):
        """ Ask the user for the delay value to set for current frame, then
            set it """
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, "Current frame delay is %i, new value in seconds: " % \
            self.mov.currentFrame.delay);
        curses.echo()
        try:
            delayValue = int(self.stdscr.getstr())
        except ValueError:
            delayValue = -1
        curses.noecho()
        self.clearStatusLine()
        if (delayValue >= 0 and delayValue <= 120): # hard limit of 0 to 120 seconds
            self.undo.push()
            self.mov.currentFrame.setDelayValue(delayValue)
        else:
            self.notify("Delay must be between 0-120 seconds.")   

    def deleteCurrentFramePrompt(self):
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, "Are you sure you want to delete the current frame? (Y/N) ");
        prompting = True
        while prompting:
            time.sleep(0.01)
            c = self.stdscr.getch()
            if (c == 121):  # 'y'
                prompting = False
                self.undo.push()
                self.mov.deleteCurrentFrame()
            elif (c == 110):    # 'n'
                prompting = False
            time.sleep(0.01)
        self.clearStatusLine()

    def safeQuit(self):
        self.stdscr.nodelay(0) # wait for input when calling getch
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, "Are you sure you want to Quit? (Y/N) " )
        prompting = True
        while (prompting):
            time.sleep(0.01)
            c = self.stdscr.getch()
            if (c == 121):   # 121 = y
                exiting = True
                prompting = False
            elif (c == 110): # 110 = n
                exiting = False
                prompting = False
            #elif (c == 27): # 27 = esc = cancel
            #    exiting = False
            #    return None
            time.sleep(0.01)
        self.clearStatusLine()
        if (exiting):
            self.verySafeQuit()

    def verySafeQuit(self): # non-interactive part.. lose out urses sreen and exit.
            curses.nocbreak()
            self.stdscr.keypad(0)
            curses.echo()
            curses.endwin()
            quit()

    def open(self):
        self.clearStatusLine()
        self.move(self.mov.sizeY, 0)
        self.stdscr.nodelay(0) # wait for input when calling getch
        self.addstr(self.mov.sizeY, 0, "File format? [I] ASCII, [D] DUR, [ESC] Cancel: ")
        prompting = True
        while (prompting):
            c = self.stdscr.getch()
            time.sleep(0.01)
            if (c == 105):   # 105 i = ascii
                loadFormat = 'ascii'
                prompting = False
            elif (c == 100): # 100 = d = dur
                loadFormat = 'dur'
                prompting = False
            elif (c == 27): # 27 = esc = cancel
                self.clearStatusLine()
                prompting = False
                return None
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, "Enter file name to open: ")
        curses.echo()
        shortfile = self.stdscr.getstr()
        curses.noecho()
        if shortfile.replace(' ', '') is '':
            self.notify("File name cannot be empty.")
            return False
        self.clearStatusLine()
        self.loadFromFile(shortfile, loadFormat)
        self.refresh()      # so we can see the new ascii in memory.
        #self.notify("Loaded " + shortfile)

    def convertToCurrentFormat(self):   # should this and loadFromFile be in a
        # separate class for file operations? or into Movie() or Options() ?
        # then loadFromFile could return a movie object instead.
        """ If we load old .dur files, convert to the latest format """
        # aka "fill in the blanks"
        if (self.opts.saveFileFormat < 3):  # version 4 should rename saveFileFormat
            # to saveFormatVersion
            # initialize color map for all frames:
            for frame in self.mov.frames:   # <3 python
                frame.initColorMap()    # that was easy
                self.opts.saveFileFormat = 3
        if (self.opts.saveFileFormat < 4):
            # old file, needs delay times populated.
            for frame in self.mov.frames:
                frame.setDelayValue(0)
                self.opts.saveFileFormat = 4

    def loadFromFile(self, shortfile, loadFormat):  # shortfile = non full path filename
        filename = os.path.expanduser(shortfile)
        if (loadFormat == 'ascii'):
            try:
                f = open(filename, 'r')
            except:
                self.notify("Could not open file for reading.")
                return None
            # here we add the stuff to load the file into self.mov.currentFrame.content[][]
            self.undo.push()
            self.mov.currentFrame.initColorMap()
            linecount = 0
            for line in f:
                if (linecount < self.mov.sizeY):    # don't exceed canvas size
                    inBuffer = list(line.strip('\n').ljust(self.mov.sizeX)) # Returns line as 80 column list of chars
                    self.mov.currentFrame.content[linecount] = inBuffer
                linecount += 1
            f.close()
            for x in range(linecount, self.mov.sizeY):   # clear out rest of contents.
                 self.mov.currentFrame.content[x] = list(" " * self.mov.sizeX)
        elif (loadFormat == 'dur'):
            try:
                f = open(filename, 'rb')
            except:
                self.notify("Could not open file for reading.")
                return None
            try:
                self.opts = pickle.load(f)
                self.mov = pickle.load(f)
            except:
                loadFormat = 'ascii'    # loading .dur format failed, so assume it's ascii instead.
                # change this to ANSI once ANSI file loading works, stripping out ^M in newlines
                # change this whole method to call loadDurFile(), loadAnsiFile(),
                # etc, checking for faiulre.
            self.convertToCurrentFormat()
            f.close()
            if (loadFormat == 'ascii'):  # loading as dur failed, so load as ascii instead.
                self.loadFromFile(shortfile, loadFormat)
        pass
    
    def save(self):
        self.clearStatusLine()
        self.move(self.mov.sizeY, 0)
        self.addstr(self.mov.sizeY, 0, "File format? [A]NSI, ASCI[I], [D]UR, [P]NG, [G]IF: ")
        self.stdscr.nodelay(0) # do not wait for input when calling getch
        prompting = True
        saved = False
        while (prompting):
            c = self.stdscr.getch()
            time.sleep(0.01)
            if (c in [105, 68]):   # 105 i = ascii
                saveFormat = 'ascii'
                prompting = False
            elif (c in [100, 68]): # 100 = d = dur, 68 = D
                saveFormat = 'dur'
                prompting = False
            elif (c in [97, 65]): # a = ansi
                saveFormat = 'ansi'
                prompting = False
            elif (c in [112, 80]): # p = png
                saveFormat = 'png'
                prompting = False
            elif (c in [103, 71]): # g = gif
                saveFormat = 'gif'
                prompting = False
            elif (c == 27): # 27 = esc = cancel
                self.clearStatusLine()
                prompting = False
                return None
        self.clearStatusLine()
        if saveFormat in ['png', 'gif']:
            self.addstr(self.mov.sizeY, 0, "Which font? IBM PC [A]NSI, AM[I]GA: ")
            prompting = True
            while (prompting):
                time.sleep(0.01)
                c = self.stdscr.getch()
                time.sleep(0.01)
                if (c in [97, 65]): # a/A = ansi
                    saveFont = 'ansi'
                    prompting = False
                elif (c in [105, 68]):   # 105 i/I = amiga
                    saveFont = 'amiga'
                    prompting = False
                elif (c == 27): # 27 = esc = cancel
                    self.clearStatusLine()
                    prompting = False
                    return None
            if saveFont is 'amiga':
                self.clearStatusLine()
                self.addstr(self.mov.sizeY, 0, "Which amiga font? 1=topaz 2=b-strict, 3=microknight, 4=mosoul, 5=pot-noodle: ")
                prompting = True
                while (prompting):
                    c = self.stdscr.getch()
                    time.sleep(0.01)
                    if c is 49: # 1 = topaz
                        saveFont = 'topaz'
                        prompting = False
                    if c is 50: # 2 = b-strict
                        saveFont = 'b-strict'
                        prompting = False
                    if c is 51: # 3 = microknight
                        saveFont = 'microknight'
                        prompting = False
                    if c is 52: # 4 = mosoul
                        saveFont = 'mosoul'
                        prompting = False
                    if c is 53: # 5 = pot-noodle
                        saveFont = 'pot-noodle'
                        prompting = False
                    elif (c == 27): # 27 = esc = cancel
                        self.clearStatusLine()
                        prompting = False
                        return None
        self.clearStatusLine()
        self.addstr(self.mov.sizeY, 0, "Enter file name to save as: ")
        curses.echo()
        filename = self.stdscr.getstr()
        curses.noecho()
        if filename.replace(' ', '') is '':
            self.notify("File name cannot be empty.")
            return False
        filename = os.path.expanduser(filename)
        # Check and see if file exists. If it does, make backup pablodraw-style.
        # Or just ask if you would like to overwrite.  haven't decided yet.
        # For now just skip the checking/backup.
        if (saveFormat == 'ascii'):
            saved = self.saveAsciiFile(filename)
        if (saveFormat == 'dur'):   # dur = pickled python objects
            saved = self.saveDurFile(filename)
        if (saveFormat == 'ansi'):  # ansi = escape codes for colors+ascii
            saved = self.saveAnsiFile(filename)
        if (saveFormat == 'png'):  # png = requires ansi love
            saved = self.savePngFile(filename, font=saveFont)
        if (saveFormat == 'gif'):  # gif = requires PIL and images2gif
            saved = self.saveGifFile(filename, font=saveFont)
        if saved:
            self.notify("*Saved* (Press any key to continue)", pause=True)
        elif not saved:
            self.notify("Save failed.")

    def saveDurFile(self, filename):
        # open and write file
        try:
            f = open(filename, 'wb')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)", pause=True)
            return False
        pickle.dump(self.opts, f)
        pickle.dump(self.mov, f)
        f.close()
        return True

    def saveAsciiFile(self, filename):
        """ Saves to ascii file, strips trailing blank lines """
        try:
            f = open(filename, 'w')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)", pause=True)
            return False
        # rewrite this. rstrip(' ') looks cool, though.
        outBuffer = '\n'.join(''.join(line).rstrip(' ') for line in self.mov.currentFrame.content).rstrip('\n')
        f.write(outBuffer + '\n\n')
        f.close()
        return True

    def saveAnsiFile(self, filename, lastLineNum=False, lastColNum=False, firstColNum=False, firstLineNum=None):
        """ Saves current frame of current movie to ansi file """
        try:
            f = open(filename, 'w')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)", pause=True)
            return False
        string = ''
        if not lastLineNum: # if we weren't told what lastLineNum is...
            # find it (last line we should save)
            lastLineNum = self.findFrameLastLine(self.mov.currentFrame)
        if not lastColNum:
            lastColNum = self.findFrameLastCol(self.mov.currentFrame)
        if not firstColNum:
            firstColNum = self.findFrameFirstCol(self.mov.currentFrame)
        if not firstLineNum:
            firstLineNum = self.findFrameFirstLine(self.mov.currentFrame)
        #for lineNum in range(0, lastLineNum):  # y is lines
        for lineNum in range(firstLineNum, lastLineNum):  # y is lines
            #for colNum in range(0, self.mov.sizeX):
            for colNum in range(firstColNum, lastColNum):
                char = self.mov.currentFrame.content[lineNum][colNum]
                color = self.mov.currentFrame.colorMap[(lineNum, colNum)]
                colorFg = color[0]
                colorBg = color[1]
                try:
                    colorCode = self.ansi.getColorCode(colorFg,colorBg)
                except KeyError:
                    colorCode = "Error: " + str(colorFg) + "," + str(colorBg) + "."
                string = string + colorCode + char
            string = string + '\r\n'
        f.write(string)
        f.write('\033[0m') # color attributes off
        string2 = string + '\r\n'   # final CR+LF (DOS style newlines)
        f.close()
        return True

    def findLastMovieLine(self, movie):    
        """ Cycle through the whole movie, figure out the lowest numbered
            line that is blank on all frames, return that #. Used to trim blank
            lines when saving. """
        movieLastLine = 1
        for frame in movie.frames:
            frameLastLine = self.findFrameLastLine(frame)
            if frameLastLine > movieLastLine:
                movieLastLine = frameLastLine
        return movieLastLine

    def findFirstMovieLine(self, movie):    
        """ Cycle through the whole movie, figure out the highest numbered
            line that is blank on all frames, return that #. Used to trim blank
            lines when saving. """
        movieFirstLine = movie.sizeY
        for frame in movie.frames:
            frameFirstLine = self.findFrameFirstLine(frame)
            if frameFirstLine < movieFirstLine:
                movieFirstLine = frameFirstLine
        return movieFirstLine

    def findFirstMovieCol(self, movie):    
        """ Cycle through the whole movie, figure out the leftmost column that
            is blank on all frames, return that #. Used to trim blank lines
            when saving. """
        movieFirstCol = movie.sizeX
        for frame in movie.frames:
            frameFirstCol = self.findFrameFirstCol(frame)
            if frameFirstCol < movieFirstCol:
                movieFirstCol = frameFirstCol
        return movieFirstCol

    def findLastMovieCol(self, movie):    
        """ Cycle through the whole movie, figure out the rightmost column
            that is blank on all frames, return that #. Used to trim blank
            lines when saving. """
        movieLastCol = 1
        for frame in movie.frames:
            frameLastCol = self.findFrameLastCol(frame)
            if frameLastCol > movieLastCol:
                movieLastCol = frameLastCol
        return movieLastCol

    def findFrameFirstLine(self, frame):
        """ For the given frame, figure out the first non-blank line, return
            that # (aka, first used line of the frame) """
        # start at the first line, work up until we find a character.
        for lineNum in range(0, self.mov.sizeY):
            for colNum in range(0, frame.sizeX):
                if not frame.content[lineNum][colNum] in [' ', '']:
                    return lineNum  # we found a non-empty character
        return 1 # blank frame, only save the first line.

    def findFrameLastLine(self, frame):
        """ For the given frame, figure out the last non-blank line, return
            that # + 1 (aka, last used line of the frame) """
        # start at the last line, work up until we find a character.
        for lineNum in reversed(range(0, self.mov.sizeY)):
            for colNum in range(0, frame.sizeX):
                if not frame.content[lineNum][colNum] in [' ', '']:
                    return lineNum + 1  # we found a non-empty character
        return 1 # blank frame, only save the first line.

    def findFrameLastCol(self, frame):
        """ For the given frame, figure out the last non-blank column, return
            that # + 1 (aka, last used column of the frame) """
        # start at the last column, work back until we find a character.
        for colNum in reversed(range(0, frame.sizeX)):
            for lineNum in reversed(range(0, self.mov.sizeY)):
                if not frame.content[lineNum][colNum] in [' ', '']:
                    return colNum + 1  # we found a non-empty character
        return 1 # blank frame, only save the first line.

    def findFrameFirstCol(self, frame):
        """ For the given frame, figure out the first non-blank column, return
            that # (aka, first used column of the frame) """
        # start at the first column, work forward until we find a character.
        for colNum in range(0, frame.sizeX):
            for lineNum in range(0, self.mov.sizeY):
                if not frame.content[lineNum][colNum] in [' ', '']:
                    return colNum  # we found a non-empty character
        return 1 # blank frame, only save the first line.

    def savePngFile(self, filename, lastLineNum=None, firstLineNum=None, firstColNum=None, lastColNum=None, font='ansi'):
        """ Save to ANSI then convert to PNG """
        if not self.appState.isAppAvail("ansilove"):   # ansilove not found
            self.notify("Ansilove not found in path. Please find it at http://ansilove.sourceforge.net/")
            return False
        tmpAnsiFileName = filename + '.tmp.ans' # remove this file when done
        tmpPngFileName = filename + '.tmp.ans.png' # remove this file when done
        if not self.saveAnsiFile(tmpAnsiFileName, lastLineNum=lastLineNum, firstLineNum=firstLineNum, firstColNum=firstColNum, lastColNum=lastColNum):
            self.notify("Saving ansi failed, make sure you can write to current directory.")
            return False
        devnull = open('/dev/null', 'w')
        if font is 'ansi':
            ansiLoveReturn = subprocess.call(['ansilove', tmpAnsiFileName, tmpPngFileName], stdout=devnull)
        else:   # amiga font
            ansiLoveReturn = subprocess.call(['ansilove', tmpAnsiFileName, font], stdout=devnull)
        devnull.close()
        os.remove(tmpAnsiFileName)
        if (ansiLoveReturn == 0): # this doesnt seem right either, as ansilove always
            pass                  # returns True. 
        else:
            self.notify("Ansilove didn't return success.")
        # crop out rightmost blank space
        if not lastColNum:
            lastColNum = self.findFrameLastCol(self.mov.currentFrame)
        if not firstColNum:
            firstColNum = self.findFrameFirstCol(self.mov.currentFrame)
        characterWidth = 8  # 9 pixels wide
        cropImage = Image.open(tmpPngFileName)
        cropWidthPixels = (lastColNum - firstColNum) * characterWidth # right
        w,h = cropImage.size
        cropBox = (0, 0, cropWidthPixels, h)  # should be right
        cropImage = cropImage.crop(cropBox)
        finalImage = open(filename, 'wb')
        try:
            cropImage.save(finalImage, "png")
            #self.notify("Saved successfully!")
            finalImage.close()
        except:
            self.notify("Error: Could not crop png.")
            os.remove(tmpPngFileName)
            return False
        os.remove(tmpPngFileName)
        return True


    def saveGifFile(self, filename, font="ansi"):
        """ check for PIL and images2gif """
        try:
            import PIL,images2gif
        except ImportError:
            self.notify("Error: Please install PIL and images2gif python modules.")
            return False
        tmpPngNames = []
        # switch to first frame
        self.mov.currentFrameNumber = 1
        self.mov.currentFrame = self.mov.frames[self.mov.currentFrameNumber - 1]
        self.refresh()
        firstMovieLineNum = self.findFirstMovieLine(self.mov) # so we can trim
        lastMovieLineNum = self.findLastMovieLine(self.mov) 
        firstMovieColNum = self.findFirstMovieCol(self.mov)
        lastMovieColNum = self.findLastMovieCol(self.mov) 
        for num in range(1, self.mov.frameCount + 1):   # then for each frame
            # make a temp png filename and add it to the list
            tmpPngName = filename + "." + str(num) + ".png"
            tmpPngNames.append(tmpPngName)
            # save the png
            if not self.savePngFile(tmpPngName, lastLineNum=lastMovieLineNum, firstLineNum=firstMovieLineNum, firstColNum=firstMovieColNum, lastColNum=lastMovieColNum, font=font):
                return False
            # If frame has a delay, copy saved file FPS times and add new
            # file names to tmpPngNames.
            if self.mov.currentFrame.delay > 0:
                for delayFrameNum in range(1,int(self.mov.currentFrame.delay) * \
                        int(self.opts.framerate)):
                    # eg: 2 second delay, 8fps, means add 16 frames.
                    delayFramePngName = tmpPngName + str(delayFrameNum) + ".png"
                    shutil.copy(tmpPngName, delayFramePngName)
                    tmpPngNames.append(delayFramePngName)
            # go to next frame
            self.mov.nextFrame()
            self.refresh()
        # open all the pngs so we can save them to gif
        pngImages = [PIL.Image.open(fn) for fn in tmpPngNames]
        sleep_time = (1000.0 / self.opts.framerate) / 1000.0    # or 0.1 is good, too
        images2gif.writeGif(filename, pngImages, duration=sleep_time)
        for rmFile in tmpPngNames:
            os.remove(rmFile)
        return True

    def showHelp(self):
        self.cursorOff()
        helpScreenText = '''
                  __                __
                _|  |__ __ _____ __|  |_____ _____ __ __ __
               / _  |  |  |   __|  _  |   __|  _  |  |  |  |\\
              /_____|_____|__|__|_____|__|___\____|________| |  Durr....
              \_____________________________________________\|  v 0.5
                /\ |\ |||\  /|            .-.  _| . _|_
               /--\| \||| \/ | ()         |/_ (_| |  |
      alt-k - next frame                  alt-' - delete current line
      alt-j - prev frame                  alt-/ - insert line
      alt-n - new frame from current      alt-, - delete current column.
      alt-N - new empty frame             alt-. - insert new column
      alt-p - play animation (up/down     alt-c - clear canvas/movie
              change FPS, any other       alt-m - mark selection for
              key stops playback)                 copy/paste/cut/move *
      alt-d - delete current frame        F1-F10 - insert character
           alt-s - save, alt-o - open, alt-h - help, alt-q - quit
              alt-up - next fg color, alt-down - prev fg color
            alt-right - next bg color, alt-left - prev bg color
        alt-z - undo, alt-r - redo, alt-D - set current frame delay
                          alt-M - move current frame

Terminal tips and more in readme.txt

'''
        self.clearStatusLine()
        self.addstr(0, 0, helpScreenText)
        self.addstr(self.mov.sizeY, 0, "* Press the ANY key to continue *")
        self.stdscr.getch()
        self.stdscr.clear()
        self.cursorOn()

    def refresh(self):          # Why doesn't this always work right? - seems good now. rename to redraw()?
        """Refresh the screen"""
        linenum = 0
        for line in self.mov.currentFrame.content:
            for colnum in range(self.mov.sizeX):
                charColor = self.mov.currentFrame.colorMap[(linenum, colnum)]
                cursesColorPair = self.ansi.colorPairMap[charColor] # set ncurss color pair
                if (charColor[0] > 8):    # bright color
                    self.addstr(linenum, colnum, str(line[colnum]), curses.color_pair(cursesColorPair) | curses.A_BOLD)
                else:
                    self.addstr(linenum, colnum, str(line[colnum]), curses.color_pair(cursesColorPair))
            linenum += 1
        for x in range(linenum, self.mov.sizeY):
            self.addstr(x, 0, " " * self.mov.sizeX)
        self.stdscr.refresh()

    def refresh2(self):
        """Refresh the Screen - rewrite"""
        pass

    def delCol(self):          # This causes ghost characters when refresh() - still? no?
        """Erase column at position of cursor"""
        self.undo.push()
        for x in range(len(self.mov.currentFrame.content)):         # Pop current column from every
            self.mov.currentFrame.content[x].pop(self.xy[1] - 1)     # line & add a blank
            self.mov.currentFrame.content[x].append(' ')         # at the end of each line.
        self.refresh()

    def addCol(self):
        """Insert column at position of cursor"""
        self.undo.push()
        for x in range(len(self.mov.currentFrame.content)):
            self.mov.currentFrame.content[x].insert(self.xy[1] - 1, ' ')
            self.mov.currentFrame.content[x].pop()
        # insert bit here to shift color map to the right from the column
        # onward. how: start at top right character, work down to bottom 
        # copying the color from the character to the left.
        # Then move left a column and repeat, etc, until you're at self.xy[1] -1 :).
        self.refresh()

    def delLine(self):
        """delete current line""" # does not move color map yet
        self.undo.push()
        self.mov.currentFrame.content.pop(self.xy[0])
        self.mov.currentFrame.content.append([])
        self.mov.currentFrame.content[len(self.mov.currentFrame.content) - 1] = list(' ' * self.mov.sizeX)
        self.refresh()

    def addLine(self):          # This causes ghost characters when refresh(). Sometimes?
        """Insert new line"""   # This doesn't move the color map yet
        self.undo.push()
        self.mov.currentFrame.content.insert(self.xy[0], list(' ' * self.mov.sizeX))
        self.mov.currentFrame.content.pop()
        self.refresh()

    def startSelecting(self, startPoint):   # startpoint is (y,x) tuple, or (self.xy[0],self.xy[1])
        """Mark selection for copy/cut/move - trigger with alt-m"""
        # set start point to where the cursor is, wait for arrow keys, enter to select, or esc to cancel.
        # when arrows are pressed, call a markBlock(x,y) function which redraws the block to be inverse.
        # then ask the user what to do with it - copy, move, cut
        # print message: "Select mode - Enter to select, Esc to cancel"
        #self.blockStartPoint =  [self.xy[0],  self.xy[1]]
        self.notify("Select mode not yet implemented.")

    def startSelectingShift(self, c, startPoint):
        """Mark selection for copy/cut/move - trigger with shift-arrow-keys"""
        # behave different.. wait for shift-arrow keys inputs.  enter selects.
        # arrow keys move the cursor and return.
        # any other key returns (cancels)
        # print message: "Select mode - Enter to select, Esc to cancel"
        self.notify("Select mode not yet implemented.")
    
    def startSelectingMouse(self, c, startPoint):
        """Mark selection for copy/cut/move - trigger with mouse click-drag"""
        self.blockStartPoint =  [self.xy[0],  self.xy[1]]
        self.notify("Select mode not yet implemented.")

    def parseArgs(self):
        """ do argparse stuff, get filename from user """
        pass

class AppState():
    """ run-time app state, separate from movie options (Options()) """
    def __init__(self):
        self.playOnlyMode = False
        self.ansiLove = self.isAppAvail("ansilove")
        self.PIL = self.checkForPIL()
        self.images2gif = self.checkForImages2gif()
        self.undoHistorySize = 100  # How far back our undo history can
    def checkForPIL(self):
        try:
            import PIL
            return True
        except ImportError:
            return False
    def checkForImages2gif(self):
        try:
            import images2gif
            return True
        except ImportError:
            return False
    def isAppAvail(self, name):   # looks for program 'name' in path
        try:
            devnull = open(os.devnull)
            subprocess.Popen([name], stdout=devnull, stderr=devnull).communicate()
        except OSError, e:
            if e.errno == os.errno.ENOENT:
                return False
        return True

class UndoManager():  # pass it a UserInterface object so Undo can tell UI
        # when to switch to another saved movie state.
        """ Manages undo/redo "stack" by storing the last 100 movie states
            in a list. Takes a UserInterface object for syntax. methods for
            push, undo and redo """
        def __init__(self, ui):
            self.ui = ui
            self.undoIndex = 0 # will be 0 when populated with 1 state.
            self.undoList = []
            self.historySize = 100  # default, but really determined by 
            # AppState values passed to setHistorySize() below.
            self.push() # push initial state
        def push(self): # maybe should be called pushState or saveState?
            """ Take current movie, add to the end of a list of movie
                objects - ie, push current state onto the undo stack. """ 
            if len(self.undoList) >= self.historySize:   # How far back our undo history can
                # go. Make this configurable.
                # if undo stack is full, dequeue from the bottom
                self.undoList.pop(0)
            # if undoIndex isn't indexing the last item in undoList,
            # ie we have redo states, remove all items after undoList[undoIndex]
            self.undoList = self.undoList[0:self.undoIndex]  # trim list
            # then add the new state to the end of the queue.
            self.undoList.append(deepcopy(self.ui.mov))
            # last item added is at the end of the list, so..
            self.undoIndex = len(self.undoList) # point index to last item
        def undo(self):
            if self.undoIndex is 1: # nothing to undo
                self.ui.notify("Nothing to undo.")
                return False
            # if we're at the end of the list, push current state so we can
            # get back to it. A bit confusing.
            if self.undoIndex is len(self.undoList):
                self.push()
                self.undoIndex -= 1
            self.undoIndex -= 1
            self.ui.mov = self.undoList[self.undoIndex] # set UI movie state
            return True # succeeded
        def redo(self):
            if self.undoIndex < (len(self.undoList) -1): # we can redo
                self.undoIndex += 1 # go to next redo state
                self.ui.mov = self.undoList[self.undoIndex] 
            else:
                self.ui.notify("Nothing to redo.")
        def setHistorySize(self, historySize):
            """ Defines the max number of undo states we will save """
            self.historySize = historySize

class ArgumentChecker: 
    """ Place to hold any methods for verifying CLI arguments, beyond
        what argparse can do on its own. Call these methods via
        argparse.add_argument(.. type= ..) paramaters. """
    def undosize(size_s):
        size = int(size_s)  # because it comes as a string
        if size >= 1 and size <= 1000:
            return size
        else:
            raise argparse.ArgumentTypeError("Undo size must be between 1 and 1000.")
            
if (__name__ == "__main__"):
    derversion = '0.5'
    derlogo = '''
       __                __
     _|  |__ __ _____ __|  |_____ _____ __ __ __
    / _  |  |  |   __|  _  |   __|  _  |  |  |  |\\
   /_____|_____|__|__|_____|__|___\____|________| |  Durr....
   \_____________________________________________\|  v %s
    Press esc-h for help.                            by cmang
''' % derversion
    argChecker = ArgumentChecker()
    parser = argparse.ArgumentParser()
    parserStartScreenMutex = parser.add_mutually_exclusive_group()
    parserFilenameMutex = parser.add_mutually_exclusive_group()
    parserFilenameMutex.add_argument("filename", nargs='?', help=".dur or ascii file to load")
    parserFilenameMutex.add_argument("-p", "--play", help="Just play .dur file or files, then exit",
                    nargs='+')
    parserStartScreenMutex.add_argument("-q", "--quick", help="Skip startup screen",
                    action="store_true")
    parserStartScreenMutex.add_argument("-w", "--wait", help="Pause at startup screen",
                    action="store_true")
    #parser.add_argument("-u", "--undosize", help="Set the number of undo history states - default is 100. More requires more RAM, less saves RAM.", nargs=1, type=argChecker.undosize) # y u no work?
    parser.add_argument("-u", "--undosize", help="Set the number of undo history states - default is 100. More requires more RAM, less saves RAM.", nargs=1, type=int)
    parser.add_argument("-V", "--version", help="Show version number and exit",
                    action="store_true")
    args = parser.parse_args()
    if args.version:
        print derversion
        exit(0)
    app = AppState()    # to store run-time preferences from CLI, environment stuff, etc.
    if args.undosize:
        app.undoHistorySize = int(args.undosize[0])
    showStartupScreen=True
    if args.play:
        showStartupScreen=False
    elif args.quick:
        showStartupScreen=False
    if showStartupScreen:
        print derlogo
        if app.ansiLove:
            print "ansilove = Found"
        else:
            print "ansilove = Not found (no PNG or GIF support)"
        if app.PIL:
            print "PIL = Found"
        else:
            print "PIL = Not found (no GIF support)"
        if app.images2gif:
            print "images2gif = Found"
        else:
            print "images2gif = Not found (no GIF support)"
        print "Undo history size = %d" % app.undoHistorySize
        if args.wait:
            try:
                choice = raw_input("Press Enter to Continue...")
            except KeyboardInterrupt:
                print("\nCaught interrupt, exiting.")
                exit(0)
        else:
            time.sleep(3)
    ui = UserInterface()
    ui.setAppState(app)
    if args.filename:
        ui.loadFromFile(args.filename, "dur")
    if args.play:
        # Just play files and exit
        app.playOnlyMode = True
        for movie in args.play:
            ui.loadFromFile(movie, "dur")
            ui.animLoop()
        ui.verySafeQuit()
    ui.refresh()
    ui.mainLoop()
