#!/usr/bin/python

"""
Durdraw by cmang (http://cmang.org) - Ascii art (animation!!!) doodling program

LICENSE:

Copyright 2009-2013 Sam Foster (cmang), all rights reserved

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
"""

import argparse,os.path,pickle,sys,time
import curses
import subprocess # for ansilove
import tempfile
from copy import copy, deepcopy

class AnsiArt():
    """ Ansi specific stuff.. escape codes, any refs to code page 437, ncurses
        color boilerplate, etc """
    def __init__(self):
        self.ColorPairMap = None # fill this with dict of FG/BG -> curses pair #
        self.escapeFgMap = {   # color numbers documented in initColorPairs() comments
            # ANSI escape code FG colors
            # regular colors, white (1) through to black (8 and 0)
            1:"0;37", 2:"0;36", 3:"0;35", 4:"0;34",
            5:"0;33", 6:"0;32", 7:"0;31", 8:"0;30", 0:"0;30",
            # bright colors, brwhite (9) through to brblack (16)
            9:"1;37", 10:"1;36", 11:"1;35", 12:"1;34",
            13:"1;33", 14:"1;32", 15:"1;31", 16:"1;30"
        }
        self.escapeBgMap = {
            1:"47", 2:"46", 3:"45", 4:"44",
            5:"43", 6:"42", 7:"41", 8:"40", 0:"40"
        }
    def getColorCode(self, fg, bg):
        """ returns a string containing ANSI escape code for given fg/bg  """
        escape = '\033['    # begin escape sequence
        escape = escape + self.escapeFgMap[fg] + ';'  # set fg color
        escape = escape + self.escapeBgMap[bg]  # set bg color
        escape = escape + "m"   # m = set graphics mode command
        return escape
    def codePage437(self): 
        pass
    def initColorPairs(self):
       """ Setup ncurses color pairs for ANSI colors """
       # this kind of hurts to write. wtf, ncurses.
       # basic ncurses colors - comments for these are durdraw internal color numbers:
       curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK) # white - 1
       curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) # cyan - 2
       curses.init_pair(3, curses.COLOR_MAGENTA, curses.COLOR_BLACK) # magenta - 3
       curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)  # blue - 4
       curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK) # yellow - 5
       curses.init_pair(6, curses.COLOR_GREEN, curses.COLOR_BLACK) # green - 6
       curses.init_pair(7, curses.COLOR_RED, curses.COLOR_BLACK) # red - 7
       curses.init_pair(8, curses.COLOR_BLACK, curses.COLOR_BLACK) # black - 8 (and 0)
       # white with background colors
       curses.init_pair(9, curses.COLOR_WHITE, curses.COLOR_WHITE) # 1,1
       curses.init_pair(10, curses.COLOR_WHITE, curses.COLOR_CYAN) # 1,2
       curses.init_pair(11, curses.COLOR_WHITE, curses.COLOR_MAGENTA) # 1,3
       curses.init_pair(12, curses.COLOR_WHITE, curses.COLOR_BLUE)  # 1,4
       curses.init_pair(13, curses.COLOR_WHITE, curses.COLOR_YELLOW)  # 1,5
       curses.init_pair(14, curses.COLOR_WHITE, curses.COLOR_GREEN) # 1,6
       curses.init_pair(15, curses.COLOR_WHITE, curses.COLOR_RED)   # 1,7
       # cyan with background colors
       curses.init_pair(16, curses.COLOR_CYAN, curses.COLOR_WHITE) # 2,1
       curses.init_pair(17, curses.COLOR_CYAN, curses.COLOR_CYAN) # 2,2
       curses.init_pair(18, curses.COLOR_CYAN, curses.COLOR_MAGENTA) # 2,3
       curses.init_pair(19, curses.COLOR_CYAN, curses.COLOR_BLUE)  # 2,4
       curses.init_pair(20, curses.COLOR_CYAN, curses.COLOR_YELLOW)  # 2,5
       curses.init_pair(21, curses.COLOR_CYAN, curses.COLOR_GREEN) # 2,6
       curses.init_pair(22, curses.COLOR_CYAN, curses.COLOR_RED)   # 2,7
       # magenta with background colors
       curses.init_pair(23, curses.COLOR_MAGENTA, curses.COLOR_WHITE) # 3,1
       curses.init_pair(24, curses.COLOR_MAGENTA, curses.COLOR_CYAN) # 3,2
       curses.init_pair(25, curses.COLOR_MAGENTA, curses.COLOR_MAGENTA) # 3,3
       curses.init_pair(26, curses.COLOR_MAGENTA, curses.COLOR_BLUE)  # 3,4
       curses.init_pair(27, curses.COLOR_MAGENTA, curses.COLOR_YELLOW)  # 3,5
       curses.init_pair(28, curses.COLOR_MAGENTA, curses.COLOR_GREEN) # 3,6
       curses.init_pair(29, curses.COLOR_MAGENTA, curses.COLOR_RED)   # 3,7
       # blue with background colors
       curses.init_pair(30, curses.COLOR_BLUE, curses.COLOR_WHITE) # 4,1
       curses.init_pair(31, curses.COLOR_BLUE, curses.COLOR_CYAN) # 4,2
       curses.init_pair(32, curses.COLOR_BLUE, curses.COLOR_MAGENTA) # 4,3
       curses.init_pair(33, curses.COLOR_BLUE, curses.COLOR_BLUE)  # 4,4
       curses.init_pair(34, curses.COLOR_BLUE, curses.COLOR_YELLOW)  # 4,5
       curses.init_pair(35, curses.COLOR_BLUE, curses.COLOR_GREEN) # 4,6
       curses.init_pair(36, curses.COLOR_BLUE, curses.COLOR_RED)   # 4,7
       # yellow with background colors
       curses.init_pair(37, curses.COLOR_YELLOW, curses.COLOR_WHITE) # 5,1
       curses.init_pair(38, curses.COLOR_YELLOW, curses.COLOR_CYAN) # 5,2
       curses.init_pair(39, curses.COLOR_YELLOW, curses.COLOR_MAGENTA) # 5,3
       curses.init_pair(40, curses.COLOR_YELLOW, curses.COLOR_BLUE)  # 5,4
       curses.init_pair(41, curses.COLOR_YELLOW, curses.COLOR_YELLOW)  # 5,5
       curses.init_pair(42, curses.COLOR_YELLOW, curses.COLOR_GREEN) # 5,6
       curses.init_pair(43, curses.COLOR_YELLOW, curses.COLOR_RED)   # 5,7
       # green with background colors
       curses.init_pair(44, curses.COLOR_GREEN, curses.COLOR_WHITE) # 6,1
       curses.init_pair(45, curses.COLOR_GREEN, curses.COLOR_CYAN) # 6,2
       curses.init_pair(46, curses.COLOR_GREEN, curses.COLOR_MAGENTA) # 6,3
       curses.init_pair(47, curses.COLOR_GREEN, curses.COLOR_BLUE)  # 6,4
       curses.init_pair(48, curses.COLOR_GREEN, curses.COLOR_YELLOW)  # 6,5
       curses.init_pair(49, curses.COLOR_GREEN, curses.COLOR_GREEN) # 6,6
       curses.init_pair(50, curses.COLOR_GREEN, curses.COLOR_RED)   # 6,7
       # red with background colors
       curses.init_pair(51, curses.COLOR_RED, curses.COLOR_WHITE) # 7,1
       curses.init_pair(52, curses.COLOR_RED, curses.COLOR_CYAN) # 7,2
       curses.init_pair(53, curses.COLOR_RED, curses.COLOR_MAGENTA) # 7,3
       curses.init_pair(54, curses.COLOR_RED, curses.COLOR_BLUE)  # 7,4
       curses.init_pair(55, curses.COLOR_RED, curses.COLOR_YELLOW)  # 7,5
       curses.init_pair(56, curses.COLOR_RED, curses.COLOR_GREEN) # 7,6
       #curses.init_pair(57, curses.COLOR_RED, curses.COLOR_RED)   # 7,7
       # black with background colors
       curses.init_pair(58, curses.COLOR_BLACK, curses.COLOR_WHITE) # 8,1
       curses.init_pair(59, curses.COLOR_BLACK, curses.COLOR_CYAN) # 8,2
       curses.init_pair(60, curses.COLOR_BLACK, curses.COLOR_MAGENTA) # 8,3
       curses.init_pair(61, curses.COLOR_BLACK, curses.COLOR_BLUE)  # 8,4
       curses.init_pair(62, curses.COLOR_BLACK, curses.COLOR_YELLOW)  # 8,5
       curses.init_pair(63, curses.COLOR_BLACK, curses.COLOR_GREEN) # 8,6
       curses.init_pair(57, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
       #curses.init_pair(64, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
       # ^ this doesn't work ?!@ ncurses pair # must be between 1 and 63
       # or ncurses (const?) COLOR_PAIR - 1 
       # fix is: have functions to swap color map from blackfg to normal.
       # call that function when drawing if the fg color is black, then switch back
       # after each character. Or.. keep track which map we're in in a variable.
       self.colorPairMap = {
            # foreground colors, black background
            (0,0):1, (1,0):1, (2,0):2, (3,0):3, (4,0):4, (5,0):5, (6,0):6, (7,0):7, (8,0):8,
            # and again, because black is both 0 and 8. :| let's just ditch 0?
            (0,8):1, (1,8):1, (2,8):2, (3,8):3, (4,8):4, (5,8):5, (6,8):6, (7,8):7, (8,8):8,
            # white with backround colors 
            (1,1):9, (1,2):10, (1,3):11, (1,4):12, (1,5):13, (1,6):14, (1,7):15,
            # cyan with backround colors 
            (2,1):16, (2,2):17, (2,3):18, (2,4):19, (2,5):20, (2,6):21, (2,7):22,
            # magenta with background colors
            (3,1):23, (3,2):24, (3,3):25, (3,4):26, (3,5):27, (3,6):28, (3,7):29,
            # blue with background colors
            (4,1):30, (4,2):31, (4,3):32, (4,4):33, (4,5):34, (4,6):35, (4,7):36,
            # yellow with background colors
            (5,1):37, (5,2):38, (5,3):39, (5,4):40, (5,5):41, (5,6):42, (5,7):43,
            # green with background colors
            (6,1):44, (6,2):45, (6,3):46, (6,4):47, (6,5):48, (6,6):49, (6,7):50,
            # red with background colors
            (7,1):51, (7,2):52, (7,3):53, (7,4):54, (7,5):55, (7,6):56, (7,7):57,
            # black with background colors
            (8,1):58, (8,2):58, (8,3):60, (8,4):61, (8,5):62, (8,6):63, 
            (8,7):57,  # 57 instead of 64, because we switch color maps for black
            # on red
            # BRIGHT COLORS 9-16
            # white with backround colors 
            (9,0):1, (9,8):1, (9,1):9, (9,2):10, (9,3):11, (9,4):12, (9,5):13, (9,6):14, (9,7):15,
            # cyan with backround colors 
            (10,0):2, (10,8):2, (10,1):16, (10,2):17, (10,3):18, (10,4):19, (10,5):20, (10,6):21, (10,7):22,
            # magenta with background colors
            (11,0):3, (11,8):3, (11,1):23, (11,2):24, (11,3):25, (11,4):26, (11,5):27, (11,6):28, (11,7):29,
            # blue with background colors
            (12,0):4, (12,8):4, (12,1):30, (12,2):31, (12,3):32, (12,4):33, (12,5):34, (12,6):35, (12,7):36,
            # yellow with background colors
            (13,0):5, (13,8):5, (13,1):37, (13,2):38, (13,3):39, (13,4):40, (13,5):41, (13,6):42, (13,7):43,
            # green with background colors
            (14,0):6, (14,8):6, (14,1):44, (14,2):45, (14,3):46, (14,4):47, (14,5):48, (14,6):49, (14,7):50,
            # red with background colors
            (15,0):7, (15,8):7, (15,1):51, (15,2):52, (15,3):53, (15,4):54, (15,5):55, (15,6):56, (15,7):57,
            # black with background colors
            (16,0):8, (16,8):8, (16,1):58, (16,2):58, (16,3):60, (16,4):61, (16,5):62, (16,6):63, 
            (16,7):57,  # 57 instead of 64, because we switch color maps for black
            } # (fg,bg):cursespair
    def switchColorMap(self, map=0):    # deprecated?  I think so.
            if (map == 1):   # 1 = black map.. deal with it. pair 57 is black on red.
                # black with background colors
                curses.init_pair(57, curses.COLOR_BLACK, curses.COLOR_RED)   # 8,7
            elif (map == 0):  # 0 = normal color map, pair 57 is red on red 
                curses.init_pair(57, curses.COLOR_RED, curses.COLOR_RED)   # 7,7


class Frame():
    """Frame class - single canvas size frame of animation. a traditional drawing.
    """
    def __init__(self, sizeX, sizeY):
        """ Iinitialize drawing.content[x][y]"""
        # it's a bunch of rows of ' 'characters.
        self.content = []
        self.sizeX = sizeX
        self.sizeY = sizeY
        for x in range(0, sizeY):
            self.content.append([])
            for y in range(0, sizeX):
                self.content[x].append(' ')
        self.initColorMap()

    def initColorMap(self):
        """ Builds a dictionary mapping X/Y to a FG/BG color pair """
        self.colorMap = {}
        for x in range(0, self.sizeY):
            for y in range(0, self.sizeX):
                self.colorMap.update( {(x,y):(1,0)} )  # tuple keypair (xy), tuple value (fg and bg)


class Options():    # config, prefs, preferences, etc. Per movie. Separate from AppState options.
    """ Member variables are canvas X/Y size, Framerate, Video resolution, etc """
    def __init__(self):         # default options
        self.framerate = 2.0
        self.sizeX = 79
        self.sizeY = 23
        self.saveFileFormat = 3 # save file format version number
        # ^ in version 2 frames have a colormap, but is not used.


class Movie():
    """ Contains an array of Frames, options to add, remove, copy them """
    def __init__(self, opts, stdscr):
        self.frameCount = 0  # total number of frames
        self.currentFrameNumber = 0
        self.sizeX = opts.sizeX
        self.sizeY = opts.sizeY
        self.frames = []
        self.stdscr = stdscr;
        self.addEmptyFrame()
        self.currentFrameNumber = self.frameCount
        self.currentFrame = self.frames[self.currentFrameNumber - 1] 

    def addEmptyFrame(self):
        newFrame = Frame(self.sizeX, self.sizeY)
        self.frames.append(newFrame)
        self.frameCount += 1

    def cloneNewFrame(self):    # clone current frame onto a new frame
        newFrame = Frame(self.sizeX, self.sizeY)
        self.frames.append(newFrame)
        newFrame.content = deepcopy(self.currentFrame.content)
        newFrame.colorMap = deepcopy(self.currentFrame.colorMap)
        self.frameCount += 1

    def deleteCurrentFrame(self):
        self.stdscr.addstr(self.sizeY, 0, " " * self.sizeX);
        self.stdscr.addstr(self.sizeY, 0, "Are you sure you want to delete the current frame? (Y/N) ");
        prompting = True
        while (prompting):
            c = self.stdscr.getch()
            if (c == 121):  # 'y'
                prompting = False
                if (self.frameCount == 1):
                    del self.frames[self.currentFrameNumber - 1]
                    # deleted the last frame, so make a blank one
                    newFrame = Frame(self.sizeX, self.sizeY)
                    self.frames.append(newFrame)
                    self.currentFrame = self.frames[self.currentFrameNumber - 1]
                else:
                    del self.frames[self.currentFrameNumber - 1]
                    self.frameCount -= 1
                    if (self.currentFrameNumber != 1):
                        self.currentFrameNumber -= 1
                    self.currentFrame = self.frames[self.currentFrameNumber - 1]
            if (c == 110):  # 'n'
                prompting = False
        self.stdscr.addstr(self.sizeY, 0, " " * self.sizeX);
    
    def nextFrame(self):
        if (self.currentFrameNumber == self.frameCount):    # if at last frame..
            self.currentFrameNumber = 1     # cycle back to the beginning
            self.currentFrame = self.frames[self.currentFrameNumber - 1] # -1 bcuz frame 1 = self.frames[0]
        else:
            self.currentFrameNumber += 1
            self.currentFrame = self.frames[self.currentFrameNumber - 1]

    def prevFrame(self):
        if (self.currentFrameNumber == 1):
            self.currentFrameNumber = self.frameCount
            self.currentFrame = self.frames[self.currentFrameNumber - 1]
        else:
            self.currentFrameNumber -= 1
            self.currentFrame = self.frames[self.currentFrameNumber - 1]
    def lastMovieLine():
        pass

class UserInterface():
    """ Draws user interface, has main UI loop. """
    def __init__(self):
        self.opts = Options()    # so we can use opts.sizeX and opts.sizeY. Needed by Frame(), subsequently Movie()
        self.appState = None # will be filled in by main() .. run-time app state stuff
        self.initCharSet()  # sometimes later options can store a char set to init - utf-8, cp437, etc.
        # initialize screen and draw the 'canvas'
        self.stdscr = curses.initscr()
        curses.start_color()    # Yeayuhhh
        curses.mousemask(1)     # it's a party now.
        self.ansi = AnsiArt()   # obj for misc ansi-related stuff
        self.ansi.initColorPairs()  # set up ncurses color pairs and fg/bg map
        self.colorfg = 1    # default fg white
        self.colorbg = 0    # default bg black
        self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        self.mov = Movie(self.opts, self.stdscr) # initialize a new movie to work with
        self.xy = [0, 1]     # cursor position x/y - was "curs"
        curses.noecho()
        #curses.cbreak()
        curses.raw()
        curses.nonl()
        self.stdscr.keypad(1)
        self.testWindowSize()
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()

    def nextFgColor(self):
        """ switch to next fg color, cycle back to beginning at max """
        #if (self.colorfg < 8):
        if (self.colorfg < 16):
            self.colorfg += 1
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorfg += 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorfg = 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def prevFgColor(self):
        """ switch to prev fg color, cycle around to end if at beginning """
        if (self.colorfg > 1):
            self.colorfg -= 1
            #if (self.colorfg == 7) and (self.colorbg == 7):  # skip over red on red
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorfg -= 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            #self.colorfg = 8
            self.colorfg = 16
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def nextBgColor(self):
        """ switch to the next bg color, cycle around if at beginning """
        if (self.colorbg < 8):
            self.colorbg += 1
            #if (self.colorfg == 7) and (self.colorbg == 7):  # skip over red on red
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorbg += 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorbg = 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def prevBgColor(self):
        """ switch to prev bg color, cycle around to end if at beginning """
        if (self.colorbg > 1):
            self.colorbg -= 1
            #if (self.colorfg == 7) and (self.colorbg == 7):  # skip over red on red
            if (self.colorfg == 7 and self.colorbg == 7) or (self.colorfg == 15 and self.colorbg == 7):  # skip over red on red
                self.colorbg -= 1
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair
        else:
            self.colorbg = 8
            self.colorpair = self.ansi.colorPairMap[(self.colorfg, self.colorbg)] # set ncurss color pair

    def notify(self, message):
        self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)
        self.stdscr.addstr(self.mov.sizeY, 0, message)
        self.stdscr.getch()
        self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)
        self.stdscr.refresh()

    def testWindowSize(self):
        """Test to see if window is too small for program to operate, and
        go into small window mode if necessary"""
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx() # test size
        if (self.realmaxY < self.mov.sizeY) or (self.realmaxX < self.mov.sizeX):
            self.smallWindowMode()   # go into small window loop.stdscr

    def smallWindowMode(self):
        """Clear the screen, draw a small message near 0,0 that the window
        is too small.  Keep doing so until the screen is resized larger."""
        self.stdscr.clear()
        self.stdscr.refresh()
        self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()
        while (self.realmaxY < self.mov.sizeY or self.realmaxX < self.mov.sizeX):
            self.stdscr.addstr(0, 0, "Window is too small.")
            self.stdscr.addstr(1, 0, "Please enlarge to 80x25 or larger.")
            self.stdscr.refresh()
            #time.sleep(1)
            self.realmaxY,self.realmaxX = self.stdscr.getmaxyx()
        self.stdscr.refresh()
        self.refresh()
        self.testWindowSize()

    def insertChar(self, c, fg=1, bg=0):
        """ insert character at current location, move cursor to the right (unless at the edge of canvas) """
        self.mov.currentFrame.content[self.xy[0]][self.xy[1] - 1] = chr(c)
        self.mov.currentFrame.colorMap.update(
                {(self.xy[0],self.xy[1] - 1):(fg,bg)} )
        if self.xy[1] < self.mov.sizeX:
            self.xy[1] = self.xy[1] + 1 

    def clearCanvas(self, prompt = False):
        prompting = prompt
        clearing = True  # assume we are clearing unless we prompt and say "n"
        if prompting:
            self.stdscr.nodelay(0) # wait for input when calling getch
            self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)
            self.stdscr.addstr(self.mov.sizeY, 0, "Are you sure you want to clear the canvas? (Y/N) " )
            while (prompting):
                c = self.stdscr.getch()
                if (c == 121):   # 121 = y
                    claering = True
                    prompting = False
                elif (c == 110): # 110 = n
                    clearing = False
                    prompting = False
            self.stdscr.addstr(self.mov.sizeY, 0, "                                                  ")
        if clearing:
            self.mov = Movie(self.opts, self.stdscr) # initialize a new movie

    def animLoop(self): # improved game loop - watches for FPS based on a delta from previous time
        self.stdscr.nodelay(1) # do not wait for input when calling getch
        last_time = time.time()
        self.stdscr.addstr(0, 0, " " * (self.mov.sizeX + 1))   # clear first line/ruler bar
        try:
            curses.curs_set(0)  # hide cursor
        except curses.error:    # unless terminal doesn't support it.
            pass
        playing = True
        new_time = time.time()
        # see how many milliseconds we have to sleep for
        # then divide by 1000.0 since time.sleep() uses seconds
        sleep_time = (1000.0 / self.opts.framerate) / 1000.0
        while (playing):
            # catch keyboard input - to change framerate or stop playing animation
            # get keyboard input, returns -1 if none available
            c = self.stdscr.getch()
            if (c != -1):   # -1 means no keys are pressed.
                # up or down to change framerate, otherwise stop playing
                if (c == curses.KEY_UP):  # up key - increase fps
                    self.opts.framerate += 1
                    sleep_time = (1000.0 / self.opts.framerate) / 1000.0
                elif (c == curses.KEY_DOWN):    # down key - decrese fps
                    if (self.opts.framerate != 1.0):
                        self.opts.framerate -= 1
                        sleep_time = (1000.0 / self.opts.framerate) / 1000.0
                else:
                    playing = False # press any key to stop
            new_time = time.time()
            if (new_time >= (last_time + sleep_time)): # Time to update the frame? If so...
                last_time = new_time
                # draw animation
                self.mov.nextFrame()
                if (self.appState.playOnlyMode == False): # if we're in play-only mode, don't show extra stuff.
                    self.stdscr.addstr(self.mov.sizeY, 10, "   " + " (" + str(self.mov.currentFrameNumber) + '/' + str(self.mov.frameCount) + ') ' + 'FPS: ' + str(self.opts.framerate) + ' ' ) # show fps
                self.refresh()
        self.stdscr.nodelay(0) # back to wait for input when calling getch
        try:
            curses.curs_set(1)  # make cursor visible again
        except curses.error:
            pass
    
    def initCharSet(self): # we can have nextCharSet and PrevCharSet to switch between chars in set
        # Can also add encoding= paramater for different encodings, eg: ascii, utf-8, etc.
        """ Map a dict of F1-f10 to character values """ 
        self.chMap = {'f1':176, 'f2':177, 'f3':178, 'f4':219, 'f5':223, 'f6':220, 'f7':221, 'f8':222, 'f9':254, 'f10':250 }
        self.chMapString = "F1%cF2%cF3%cF4%cF5%cF6%cF7%cF8%cF9%cF10%c" % \
                (self.chMap['f1'], self.chMap['f2'], self.chMap['f3'], self.chMap['f4'], self.chMap['f5'], \
                self.chMap['f6'], self.chMap['f7'], self.chMap['f8'], self.chMap['f9'], self.chMap['f10'], )

    def mainLoop(self):
        self.metaKey = 0
        self.stdscr.addstr(self.mov.sizeY, 10, "   " + " (" + str(self.mov.currentFrameNumber) + '/' + str(self.mov.frameCount) + ') ' + 'FPS: ' + str(self.opts.framerate) + ' ' )  # FPS and frame number
        while 1:    # Real "main loop" - get user input, aka "edit mode"
            self.testWindowSize()
            # print statusbar stuff
            self.stdscr.addstr(self.mov.sizeY, 1, str(self.xy))     # line/column number (line starts at 0)
            # f1-f10 map
            self.stdscr.addstr(self.mov.sizeY, self.mov.sizeX - len(self.chMapString), self.chMapString, curses.color_pair(self.colorpair))
            # color thing
            colorString = " Color (%i,%i)" % (self.colorfg, self.colorbg)
            #self.stdscr.addstr(self.mov.sizeY, self.mov.sizeX - len(colorString + " " + self.chMapString), colorString, curses.color_pair(self.colorpair)) # for debugging color numbers
            if self.colorfg > 8:    # bold color
                #self.stdscr.attron(curses.A_BOLD)
                #self.stdscr.addstr(self.mov.sizeY, self.mov.sizeX - len(colorString + " " + self.chMapString), colorString + "*", curses.color_pair(self.colorpair) | curses.A_BOLD)
                self.stdscr.addstr(self.mov.sizeY, self.mov.sizeX - len(self.chMapString), self.chMapString, curses.color_pair(self.colorpair) | curses.A_BOLD)
                #self.stdscr.attroff(curses.A_BOLD)
            self.stdscr.move(self.xy[0], self.xy[1] - 1)  # move cursor to the right spot for refresh
            self.stdscr.refresh()
            c = self.stdscr.getch()
            self.testWindowSize()
            try:    # in case self.stdscr.addstr() returns ERR <- still doesn't catch it or fix problem
                self.stdscr.addstr(self.mov.sizeY, 0, " " * 10)
                #if c == 203: self.notify('Whaaaaat???')
                if c in ["\x1b\x1b\x5b\x42"]: self.notify("alt-down")
                if self.metaKey == 1:
                    # Try for meta-keys, then set metaKey to 1
                    if c == 111:                # alt-o - open
                        self.open()
                        c = None
                    elif c == 115:                 # alt-s - save
                        self.save()
                        c = None
                    elif c == 113:                 # alt-q - quit
                        self.safeQuit()
                        c = None
                    elif c == 104:                # alt-h - help
                        self.showHelp()
                        c = None
                    elif c in [98, curses.KEY_LEFT]:      # alt-left - prev bg color
                        self.prevBgColor()
                        c = None
                    elif c in [102, curses.KEY_RIGHT]:     # alt-right - next bg color
                        self.nextBgColor()
                        c = None
                    elif c in [curses.KEY_DOWN, "\x1b\x1b\x5b\x42"]:      # alt-down - prev fg color
                        self.prevFgColor()
                        #self.notify("fg color:" + str(self.colorfg))
                        c = None
                    elif c == curses.KEY_UP:     # alt-up - next fg color
                        self.nextFgColor()
                        #self.notify("fg color:" + str(self.colorfg))
                        c = None
                    elif c == 44:      # alt-, - erase/pop current column
                        self.delCol()
                    elif c == 46:       # alt-. - insert column
                        self.addCol()
                    elif c == 39:        # alt-' - erase line
                        self.delLine()
                    elif c == 47:      # alt-/ - insert line
                        self.addLine()
                    elif (c == 109):    # alt-m - mark block
                        startPoint=(self.xy[0], self.xy[1])
                        self.startSelecting(startPoint)
                    elif (c == 99):     # alt-c - clear canvas
                        self.clearCanvas(prompt = True)
                    # Animation Keystrokes
                    elif (c == 107):          # esc-k - next frame
                        self.mov.nextFrame()
                        self.refresh()  
                    elif (c == 106):          # esc-j or alt-j - previous frame
                        self.mov.prevFrame()
                        self.refresh()
                    elif (c == 110) or (c == 14):          # alt-n - clone to new frame
                        self.mov.cloneNewFrame()
                        self.refresh()
                    elif (c == 78):          # alt-N (shift-alt-n) - new  empty frame
                        self.mov.addEmptyFrame()
                        self.refresh()
                    elif (c == 100):      # esc-d - delete current frame
                        self.mov.deleteCurrentFrame()
                        self.refresh()
                    elif (c == 112):    # esc-p - start playing, any key exits
                        self.animLoop()
                    else: self.notify("keystroke: %d" % c)
                    self.metaKey = 0
                    c = None
                #if c == 27: self.safeQuit()    # 27 = ^[, used for meta-key
                if c == 27: self.metaKey = 1; c = None
                if c == 24: self.safeQuit()     # ctrl-x
                elif c == 15:               # ctrl-o - open
                    self.open()
                    c = None
                elif c == 23:               # ctrl-w - save
                    self.save()
                    c = None
                elif c == 12:               # ctrl-l - refresh
                    self.refresh()
                    c = None
                elif c == 13:               # enter (10 if we don't do curses.nonl())
                    if self.xy[0] < self.mov.sizeX - 1:
                        self.xy = [self.xy[0] + 1, 1]
                elif c in [263, 127]:              # backspace
                    if self.xy[1] > 1: self.xy[1] = self.xy[1] - 1
                elif c in [1, curses.KEY_HOME]:     # ctrl-a or home
                    self.xy[1] = 1
                elif c in [5, curses.KEY_END]:      # ctrl-e or end
                    self.xy[1] = self.mov.sizeX
                #elif c in [curses.KEY_F1, 7]:    # F1 .. insert block character?
                elif c in [curses.KEY_F1]:    # F1 - insert extended character
                    self.insertChar(self.chMap['f1'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F2]:    # F2 - insert extended character
                    self.insertChar(self.chMap['f2'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F3]:    # F3 - insert extended character
                    self.insertChar(self.chMap['f3'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F4]:    # F4 - insert extended character
                    self.insertChar(self.chMap['f4'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F5]:    # F5 - insert extended character
                    self.insertChar(self.chMap['f5'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F6]:    # F6 - insert extended character
                    self.insertChar(self.chMap['f6'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F7]:    # F7 - insert extended character
                    self.insertChar(self.chMap['f7'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F8]:    # F8 - insert extended character
                    self.insertChar(self.chMap['f8'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F9]:    # F9 - insert extended character
                    self.insertChar(self.chMap['f9'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c in [curses.KEY_F10]:    # F10 - insert extended character
                    self.insertChar(self.chMap['f10'], fg=self.colorfg, bg=self.colorbg)
                    c = None
                elif c == curses.KEY_LEFT:
                    if self.xy[1] > 1: self.xy[1] = self.xy[1] - 1
                elif c == curses.KEY_RIGHT:
                    if self.xy[1] < self.mov.sizeX: self.xy[1] = self.xy[1] + 1
                elif c == curses.KEY_UP:
                    #if self.xy[0] > 1: self.xy[0] = self.xy[0] - 1
                    if self.xy[0] > 0: self.xy[0] = self.xy[0] - 1
                elif c == curses.KEY_DOWN:
                    if self.xy[0] < self.mov.sizeY - 1: self.xy[0] = self.xy[0] + 1
                #elif c == curses.KEY_HOME:  # 339 = home
                elif c == 339:  # 339 = home
                    self.xy[1] = 1
                #elif c == curses.KEY_END:   # 338 = end
                elif c == 338:   # 338 = end
                    self.xy[1] = self.mov.sizeX
                elif c == curses.KEY_MOUSE: # mouse = move cursor, etc
                    mouseEvent = curses.getmouse()
                    _, mouseX, mouseY, _, _ = curses.getmouse()
                    if mouseY < self.mov.sizeY:
                        self.xy[1] = mouseX + 1
                        self.xy[0] = mouseY
                    #self.mouseClicked(mouseEvent)
                elif c in [curses.KEY_SLEFT, curses.KEY_SRIGHT, 337, 336, 520, 513]:
                    # 337 and 520 - shift-up, 336 and 513 = shift-down
                    # shift-up, shift-down, shift-left and shift-right = start selecting text block
                    # shift-up and shift-down not defined in ncurses :(
                    # doesn't seem to work in screen?
                    startPoint=(self.xy[0], self.xy[1])
                    self.startSelectingShift(c, startPoint)  # start selecting text
                    # pass c to something here that starts selecting and moves
                    # the cursor based on c, and knows whether it's selecting
                    # via shift-arrow or mouse.
                elif c <= 128 and c >= 32:      # normal printable character
                    self.insertChar(c, fg=self.colorfg, bg=self.colorbg)
                if (c != None):
                    self.stdscr.addstr(self.mov.sizeY, 10, str(c) + " (" + str(self.mov.currentFrameNumber) + '/' + str(self.mov.frameCount) + ') ' + 'FPS: ' + str(self.opts.framerate) + ' ' )  # This is basically our statusbar, left side. should format this separately.
                if (c == None):
                    self.stdscr.addstr(self.mov.sizeY, 10, "   " + " (" + str(self.mov.currentFrameNumber) + '/' + str(self.mov.frameCount) + ') ' + 'FPS: ' + str(self.opts.framerate) + ' ' )
                self.refresh()
                #self.stdscr.addstr(0, self.xy[1] - 1, longstring[self.xy[1] - 1], curses.A_STANDOUT)
            #except Exception, err:
            except curses.error:
                self.smallWindowMode()

    def safeQuit(self):
        self.stdscr.nodelay(0) # wait for input when calling getch
        self.stdscr.addstr(self.mov.sizeY, 0, "                                               ")
        self.stdscr.addstr(self.mov.sizeY, 0, "Are you sure you want to Quit? (Y/N) " )
        prompting = True
        while (prompting):
            c = self.stdscr.getch()
            if (c == 121):   # 121 = y
                exiting = True
                prompting = False
            elif (c == 110): # 110 = n
                exiting = False
                prompting = False
            #elif (c == 27): # 27 = esc = cancel
            #    exiting = False
            #    return None
        self.stdscr.addstr(self.mov.sizeY, 0, " " * 50)
        if (exiting):
            self.verySafeQuit()

    def verySafeQuit(self): # non-interactive part.. lose out urses sreen and exit.
            curses.nocbreak()
            self.stdscr.keypad(0)
            curses.echo()
            curses.endwin()
            quit()

    def open(self):
        self.stdscr.addstr(self.mov.sizeY, 0, " " * (self.mov.sizeX-1))     # clear status line
        self.stdscr.move(self.mov.sizeY, 0)
        self.stdscr.nodelay(0) # wait for input when calling getch
        self.stdscr.addstr(self.mov.sizeY, 0, "File format? [I] ASCII, [D] DUR, [ESC] Cancel: ")
        prompting = True
        while (prompting):
            c = self.stdscr.getch()
            if (c == 105):   # 105 i = ascii
                loadFormat = 'ascii'
                prompting = False
            elif (c == 100): # 100 = d = dur
                loadFormat = 'dur'
                prompting = False
            elif (c == 27): # 27 = esc = cancel
                self.stdscr.addstr(self.mov.sizeY, 0, "                                               ")
                prompting = False
                return None
        self.stdscr.addstr(self.mov.sizeY, 0, "                                               ")
        self.stdscr.addstr(self.mov.sizeY, 0, "Enter file name to open: ")
        curses.echo()
        shortfile = self.stdscr.getstr()
        curses.noecho()
        self.stdscr.addstr(self.mov.sizeY, 0, " " * (self.mov.sizeX - 1))
        self.loadFromFile(shortfile, loadFormat)
        self.refresh()      # so we can see the new ascii in memory.
        #self.notify("Loaded " + shortfile)

    def convertToCurrentFormat(self):   # should this and loadFromFile be in a
        # separate class for file operations? or into Movie() or Options() ?
        # then loadFromFile could return a movie object instead.
        """ If we load old .dur files, convert to the latest format """
        # aka "fill in the blanks"
        if (self.opts.saveFileFormat < 3):  # version 4 should rename saveFileFormat
            # to saveFormatVersion
            # initialize color map for all frames:
            for frame in self.mov.frames:   # <3 python
                frame.initColorMap()    # that was easy
                self.opts.saveFileFormat = 3

    def loadFromFile(self, shortfile, loadFormat):  # shortfile = non full path filename
        filename = os.path.expanduser(shortfile)
        if (loadFormat == 'ascii'):
            try:
                f = open(filename, 'r')
            except:
                self.notify("Could not open file for reading.")
                return None
            # here we add the stuff to load the file into self.mov.currentFrame.content[][]
            #linecount = 1
            linecount = 0
            for line in f:
                if (linecount < self.mov.sizeY):    # don't exceed canvas size
                    inBuffer = list(line.strip('\n').ljust(self.mov.sizeX)) # Returns line as 80 column list of chars
                    self.mov.currentFrame.content[linecount] = inBuffer
                linecount += 1
            f.close()
            for x in range(linecount, self.mov.sizeY):   # clear out rest of contents.
                 self.mov.currentFrame.content[x] = list(" " * self.mov.sizeX)
        elif (loadFormat == 'dur'):
            try:
                f = open(filename, 'rb')
            except:
                self.notify("Could not open file for reading.")
                return None
            try:
                self.opts = pickle.load(f)
                self.mov = pickle.load(f)
            except:
                loadFormat = 'ascii'    # loading .dur format failed, so assume it's ascii instead
            self.mov.stdscr = self.stdscr
            self.convertToCurrentFormat()
            f.close()
            if (loadFormat == 'ascii'):  # loading as dur failed, so load as ascii instead.
                self.loadFromFile(shortfile, loadFormat)
        pass
    
    def save(self):
        self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)     # clear status line
        self.stdscr.move(self.mov.sizeY, 0)
        self.stdscr.addstr(self.mov.sizeY, 0, "File format? [A]NSI, ASCI[I], [D]UR, [P]NG, [G]IF: ")
        self.stdscr.nodelay(0) # do not wait for input when calling getch
        prompting = True
        saved = False
        while (prompting):
            c = self.stdscr.getch()
            if (c in [105, 68]):   # 105 i = ascii
                saveFormat = 'ascii'
                prompting = False
            elif (c in [100, 68]): # 100 = d = dur, 68 = D
                saveFormat = 'dur'
                prompting = False
            elif (c in [97, 65]): # a = ansi
                saveFormat = 'ansi'
                prompting = False
            elif (c in [112, 80]): # p = png
                saveFormat = 'png'
                prompting = False
            elif (c in [103, 71]): # g = gif
                saveFormat = 'gif'
                prompting = False
            elif (c == 27): # 27 = esc = cancel
                self.stdscr.addstr(self.mov.sizeY, 0, "                                 ")
                prompting = False
                return None
        self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)
        self.stdscr.addstr(self.mov.sizeY, 0, "Enter file name to save as: ")
        curses.echo()
        filename = self.stdscr.getstr()
        curses.noecho()
        filename = os.path.expanduser(filename)
        # Check and see if file exists. If it does, make backup pablodraw-style.
        # Or just ask if you would like to overwrite.  haven't decided yet.
        # For now just skip the checking.
        if (saveFormat == 'ascii'):
            saved = self.saveAsciiFile(filename)
        if (saveFormat == 'dur'):   # dur = pickled python objects
            saved = self.saveDurFile(filename)
        if (saveFormat == 'ansi'):  # ansi = escape codes for colors + ascii
            saved = self.saveAnsiFile(filename)
        if (saveFormat == 'png'):  # png = requires ansi love
            saved = self.savePngFile(filename)
        if (saveFormat == 'gif'):  # gif = requires PIL and images2gif
            saved = self.saveGifFile(filename)
        if saved:
            self.notify("*Saved* (Press any key to continue)")
        elif not (saved):
            self.notify("Save failed.")
        self.stdscr.getch()
        self.stdscr.addstr(self.mov.sizeY, 0, " " * (self.mov.sizeX-1))

    def saveDurFile(self, filename):
        # remove un-picklable objects
        self.mov.stdscr = None
        # open ad write file
        try:
            f = open(filename, 'wb')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)")
            return False
        pickle.dump(self.opts, f)
        pickle.dump(self.mov, f)
        f.close()
        self.mov.stdscr = self.stdscr   # re-insert un-picklable object
        return True

    def saveAsciiFile(self, filename):
        """ Saves to ascii file, strips trailing blank lines """
        try:
            f = open(filename, 'w')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)")
            return False
        outBuffer = '\n'.join(''.join(line).rstrip(' ') for line in self.mov.currentFrame.content).rstrip('\n') 
        f.write(outBuffer + '\n\n')
        f.close()
        return True

    def saveAnsiFile(self, filename, lastLineNum=False):
        """ Saves current frame of current movie to ansi file """
        try:
            f = open(filename, 'w')
        except:
            self.notify("Could not open file for writing. (Press any key to continue)")
            return False
        string = ''
        # put something here to find last line in frame, unless saveAnsiFile
        # is passed lastLineNum=
        if not lastLineNum:
            lastLineNum = self.findLastFrameLine(self.mov.currentFrame)
        for lineNum in range(0, lastLineNum):  # y is lines
            for colNum in range(0, self.mov.sizeX):
                char = self.mov.currentFrame.content[lineNum][colNum]
                color = self.mov.currentFrame.colorMap[(lineNum, colNum)]
                colorFg = color[0]
                colorBg = color[1]
                #string = string + str(color)
                try:
                    colorCode = self.ansi.getColorCode(colorFg,colorBg)
                except KeyError:
                    colorCode = "Error: " + str(colorFg) + "," + str(colorBg) + "."
                string = string + colorCode + char
            string = string + '\r\n'
        f.write(string)
        f.write('\033[0m') # color attributes off
        string2 = string + '\r\n'   # final CR+LF (DOS style newlines)
        f.close()
        return True

    def findLastMovieLine(self, movie):    
        """ Cycle through the whole movie, figure out the lowest numbered
            line that is blank on all frames, return that #. Used to trim blank
            lines when saving. """
        movieLastLine = 1
        for frame in movie.frames:
            frameLastLine = self.findLastFrameLine(frame)
            if frameLastLine > movieLastLine:
                movieLastLine = frameLastLine
        return movieLastLine

    def findLastFrameLine(self, frame):
        """ For the given frame, figure out the last non-blank line, return
            that # + 1 (aka, last used line of the frame) """
        # start at the last line, work up until we find a character.
        for lineNum in reversed(range(0, self.mov.sizeY)):
            for colNum in range(0, frame.sizeX):
                if not frame.content[lineNum][colNum] in [' ', '']:
                    return lineNum + 1  # we found a non-empty character
        return 1 # blank frame, only save the first line.

    def savePngFile(self, filename, lastLineNum=None):
        """ Save to ANSI then convert to PNG """
        if not self.appState.isAppAvail("ansilove"):   # ansilove not found
            self.notify("Ansilove not found in path. Please find it at http://ansilove.sourceforge.net/")
            return False
        tmpAnsiFile = filename + '.tmp.ans' # remove this file when done
        tmpPngFile = filename + '.tmp.ans.png' # remove this file when done
        if not self.saveAnsiFile(tmpAnsiFile, lastLineNum):
            self.notify("Saving ansi failed, make sure you can write to current directory.")
            return False
        devnull = open('/dev/null', 'w')
        ansiLoveReturn = subprocess.call(['ansilove', tmpAnsiFile, tmpPngFile], stdout=devnull)
        devnull.close()
        subprocess.call(['mv', tmpPngFile, filename])
        subprocess.call(['rm', tmpAnsiFile])
        if (ansiLoveReturn == 0):
            #self.notify("File saved!") # move this to a better spot
            return True
        else:
            self.notify("Ansilove didn't return success.")

    def saveGifFile(self, filename):
        """ check for PIL and images2gif """
        try:
            import PIL,images2gif
        except ImportError:
            self.notify("Error: Please install PIL and images2gif python modules.")
            return False
        tmpPngNames = []
        # switch to first frame
        self.mov.currentFrameNumber = 1
        self.mov.currentFrame = self.mov.frames[self.mov.currentFrameNumber - 1]
        self.refresh()
        lastMovieLineNum = self.findLastMovieLine(self.mov)  # so we can trim
        for num in range(1, self.mov.frameCount + 1):   # then for each frame
            # make a temp png filename and add it to the list
            tmpPngName = filename + "." + str(num) + ".png"
            tmpPngNames.append(tmpPngName)
            # save the png
            if not self.savePngFile(tmpPngName, lastLineNum=lastMovieLineNum):
                return False
            # go to next frame
            self.mov.nextFrame()
            self.refresh()
        # open all the pngs so we can save them to gif
        pngImages = [PIL.Image.open(fn) for fn in tmpPngNames]
        sleep_time = (1000.0 / self.opts.framerate) / 1000.0    # or 0.1 is good, too
        images2gif.writeGif(filename, pngImages, duration=sleep_time)
        for rmFile in tmpPngNames:
            os.remove(rmFile)
        return True

    def showHelp(self):
        curses.curs_set(0)
        helpScreenText = '''
                  __                __
                _|  |__ __ _____ __|  |_____ _____ __ __ __
               / _  |  |  |   __|  _  |   __|  _  |  |  |  |\\
              /_____|_____|__|__|_____|__|___\____|________| |  Durr....
              \_____________________________________________\|  v 0.4
                /\ |\ |||\  /|            .-.  _| . _|_
               /--\| \||| \/ | ()         |/_ (_| |  |
      alt-k - next frame                  alt-' - delete current line
      alt-j - prev frame                  alt-/ - insert line
      alt-n - new frame from current      alt-, - delete current column.
      alt-N - new empty frame             alt-. - insert new column
      alt-p - play animation (up/down     alt-c - clear canvas/movie
              change FPS, any other       alt-m - mark selection for
              key stops playback)                 copy/paste/cut/move *
      alt-d - delete current frame        F1-F10 - insert character
   ..  ..----------------------------------------------------------..  ..
           alt-s - save, alt-o - open, alt-h - help, alt-q - quit
              alt-up - next fg color, alt-down - prev fg color
            alt-right - next fg color, alt-left - prev fg color

Terminal tips in readme.txt

'''
        self.stdscr.addstr(self.mov.sizeY, 0, " " * self.mov.sizeX)
        self.stdscr.addstr(0, 0, helpScreenText)
        self.stdscr.addstr(self.mov.sizeY, 0, "* Press the ANY key to continue *")
        self.stdscr.getch()
        self.stdscr.clear()
        curses.curs_set(1)

    def refresh(self):          # Why doesn't this always work right? - seems good now. rename to redraw()?
        """Refresh the screen"""
        linenum = 0
        for line in self.mov.currentFrame.content:
            for colnum in range(self.mov.sizeX):
                charColor = self.mov.currentFrame.colorMap[(linenum, colnum)]
                cursesColorPair = self.ansi.colorPairMap[charColor] # set ncurss color pair
                # check for charColor = (8,7) black on red
                #if charColor == (8,7):
                #    self.ansi.switchColorMap(map=1)
                #    self.stdscr.addstr(linenum, colnum, str(line[colnum]), curses.color_pair(cursesColorPair))
                #    self.ansi.switchColorMap(map=0)
                #else:
                if (charColor[0] > 8):    # bright color
                    #self.stdscr.attron(curses.A_BOLD)
                    self.stdscr.addstr(linenum, colnum, str(line[colnum]), curses.color_pair(cursesColorPair) | curses.A_BOLD)
                    #self.stdscr.attroff(curses.A_BOLD)
                else:
                    self.stdscr.addstr(linenum, colnum, str(line[colnum]), curses.color_pair(cursesColorPair))
            linenum += 1
        for x in range(linenum, self.mov.sizeY):
            self.stdscr.addstr(x, 0, " " * self.mov.sizeX)
        # draw statusbar should be in here?
        #self.stdscr.addstr(self.mov.sizeY, 10, str(c) + " (" + str(self.mov.currentFrameNumber) + '/' + str(self.mov.frameCount) + ' )' ) 
        self.stdscr.refresh()

    def refresh2(self):
        """Refresh the Screen - rewrite"""
        pass

    def delCol(self):          # This causes ghost characters when refresh() - still? no?
        """Erase column at position of cursor"""
        for x in range(len(self.mov.currentFrame.content)):         # Pop current column from every
            self.mov.currentFrame.content[x].pop(self.xy[1] - 1)     # line & add a blank
            self.mov.currentFrame.content[x].append(' ')         # at the end of each line.
        self.refresh()

    def addCol(self):
        """Insert column at position of cursor"""
        for x in range(len(self.mov.currentFrame.content)):
            self.mov.currentFrame.content[x].insert(self.xy[1] - 1, ' ')
            self.mov.currentFrame.content[x].pop()
        # insert bit here to shift color map to the right from the column
        # onward. how: start at top right character, work down to bottom 
        # copying the color from the character to the left.
        # Then move left a column and repeat, etc, until you're at self.xy[1] -1 :).
        self.refresh()

    def delLine(self):
        """delete current line""" # does not move color map yet
        self.mov.currentFrame.content.pop(self.xy[0])
        self.mov.currentFrame.content.append([])
        self.mov.currentFrame.content[len(self.mov.currentFrame.content) - 1] = list(' ' * self.mov.sizeX)
        self.refresh()

    def addLine(self):          # This causes ghost characters when refresh(). Sometimes?
        """Insert new line"""   # This doesn't move the color map yet
        self.mov.currentFrame.content.insert(self.xy[0], list(' ' * self.mov.sizeX))
        self.mov.currentFrame.content.pop()
        self.refresh()

    def startSelecting(self, startPoint):   # startpoint is (y,x) tuple, or (self.xy[0],self.xy[1])
        """Mark selection for copy/cut/move - trigger with alt-m"""
        # set start point to where the cursor is, wait for arrow keys, enter to select, or esc to cancel.
        # when arrows are pressed, call a markBlock(x,y) function which redraws the block to be inverse.
        # then ask the user what to do with it - copy, move, cut
        # print message: "Select mode - Enter to select, Esc to cancel"
        #self.blockStartPoint =  [self.xy[0],  self.xy[1]]
        self.notify("Select mode (not yet implemented)")

    def startSelectingShift(self, c, startPoint):
        """Mark selection for copy/cut/move - trigger with shift-arrow-keys"""
        # behave different.. wait for shift-arrow keys inputs.  enter selects.
        # arrow keys move the cursor and return.
        # any other key returns (cancels)
        # print message: "Select mode - Enter to select, Esc to cancel"
        self.notify("Select mode (not yet implemented)")
    
    def startSelectingMouse(self, c, startPoint):
        """Mark selection for copy/cut/move - trigger with mouse click-drag"""
        self.blockStartPoint =  [self.xy[0],  self.xy[1]]
        self.notify("Select mode (not yet implemented)")

    def parseArgs(self):
        """ do argparse stuff, get filename from user """
        pass

class AppState():
    """ run-time app state, separate from movie options (Options()) """
    def __init__(self):
        self.playOnlyMode = False
        self.ansiLove = self.isAppAvail("ansilove")
        self.PIL = self.checkForPIL()
        self.images2gif = self.checkForImages2gif()
    def checkForPIL(self):
        try:
            import PIL
            return True
        except ImportError:
            return False
    def checkForImages2gif(self):
        try:
            import images2gif
            return True
        except ImportError:
            return False
    def isAppAvail(self, name):   # looks for program 'name' in path
        try:
            devnull = open(os.devnull)
            subprocess.Popen([name], stdout=devnull, stderr=devnull).communicate()
        except OSError, e:
            if e.errno == os.errno.ENOENT:
                return False
        return True

class UndoManager():
        """ Manages undo/redo "stack" by storing the last 50 movie states.
            Takes a movie for syntax. methods for push, pop and redo """
            
if (__name__ == "__main__"):
    derversion = '0.4'
    derlogo = '''
       __                __
     _|  |__ __ _____ __|  |_____ _____ __ __ __
    / _  |  |  |   __|  _  |   __|  _  |  |  |  |\\
   /_____|_____|__|__|_____|__|___\____|________| |  Durr....
   \_____________________________________________\|  v %s
    Press esc-h for help.                            by cmang
''' % derversion
    parser = argparse.ArgumentParser()
    parserMutex = parser.add_mutually_exclusive_group()
    parser.add_argument("filename", nargs='?', help=".dur or ascii file to load")
    parser.add_argument("-p", "--play", help="Just play .dur file, then exit",
                    action="store_true")
    parserMutex.add_argument("-q", "--quick", help="Skip startup screen",
                    action="store_true")
    parserMutex.add_argument("-w", "--wait", help="Pause at startup screen",
                    action="store_true")
    parser.add_argument("-V", "--version", help="Show version number and exit",
                    action="store_true")
    args = parser.parse_args()
    if args.version:
        print derversion
        exit(0)
    app = AppState()    # to store run-time preferences from CLI, environment stuff, etc.
    showStartupScreen=True
    if args.play:
        showStartupScreen=False
    elif args.quick:
        showStartupScreen=False
    if showStartupScreen:
        print derlogo
        if app.ansiLove:
            print "ansilove = Found"
        else:
            print "ansilove = Not found (no PNG or GIF support)"
        if app.PIL:
            print "PIL = Found"
        else:
            print "PIL = Not found (no GIF support)"
        if app.images2gif:
            print "images2gif = Found"
        else:
            print "images2gif = Not found (no GIF support)"
        if args.wait:
            choice = raw_input("Press Enter to Continue...")
        else:
            time.sleep(3)
    ui = UserInterface()
    ui.appState = app
    if args.filename:
        ui.loadFromFile(args.filename, "dur")
    if args.play:
        # Just play file and exit
        app.playOnlyMode = True
        ui.animLoop()
        ui.verySafeQuit()
    ui.refresh()
    ui.mainLoop()
